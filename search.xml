<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android 触摸系列（二）ViewGroup.dispatchTouchEvent源码(28)分析]]></title>
    <url>%2F2019%2F08%2FAndroid%E8%A7%A6%E6%91%B8-Android-%E8%A7%A6%E6%91%B8%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89ViewGroup-dispatchTouchEvent%E6%BA%90%E7%A0%81-28-%E5%88%86%E6%9E%90.html</url>
    <content type="text"><![CDATA[一、先看View.dispatchTouchEvent源码View.dispatchTouchEvent源码很简单简化看就是OnTouchListener优先调用，要是消耗掉事件则不在调用View.onTouchEvent，还有NestedScroll相关这里先不展开说后续文章会有源码分析。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public boolean dispatchTouchEvent(MotionEvent event) &#123; // If the event should be handled by accessibility focus first. if (event.isTargetAccessibilityFocus()) &#123; // We don't have focus or no virtual descendant has it, do not handle the event. if (!isAccessibilityFocusedViewOrHost()) &#123; return false; &#125; // We have focus and got the event, then use normal event dispatch. event.setTargetAccessibilityFocus(false); &#125; boolean result = false; if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(event, 0); &#125; final int actionMasked = event.getActionMasked(); if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Defensive cleanup for new gesture stopNestedScroll(); &#125; if (onFilterTouchEventForSecurity(event)) &#123; if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123; result = true; &#125; //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125; if (!result &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(event, 0); &#125; // Clean up after nested scrolls if this is the end of a gesture; // also cancel it if we tried an ACTION_DOWN but we didn't want the rest // of the gesture. if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123; stopNestedScroll(); &#125; return result; &#125; 二、ViewGroup.dispatchTouchEvent源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225public boolean dispatchTouchEvent(MotionEvent ev) &#123; //做源码开发预留的测试代码，mInputEventConsistencyVerifier在View源码上 if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(ev, 1); &#125; // 如果事件以可访问性焦点视图为目标，就是这样，开始 // 正常事件调度。也许后代是处理点击的东西。 //isAccessibilityFocusedViewOrHost 判断当前Window中焦点View是不是this if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123; //清理焦点调用到native ev.setTargetAccessibilityFocus(false); &#125; boolean handled = false; //过滤触摸事件以应用安全策略。校验View.FILTER_TOUCHES_WHEN_OBSCURED与MotionEvent.FLAG_WINDOW_IS_OBSCURED标记，“窗口被遮挡 不处理时间” if (onFilterTouchEventForSecurity(ev)) &#123; final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; // 在Down初始化处理事件 if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // 在开始新的触摸手势时丢弃所有先前的状态。 // 由于应用程序切换，ANR或某些其他状态更改， // 框架可能已放弃上一个手势的up或cancel事件 cancelAndClearTouchTargets(ev); resetTouchState(); &#125; // 检查拦截。 final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; //检查子View是否请求不拦截 final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // 恢复操作，以防它被更改 &#125; else &#123; intercepted = false; &#125; &#125; else &#123; // 在没有触摸布标与不是Down事件时默认拦截 intercepted = true; &#125; // 如果被拦截，则启动正常事件调度。此外，如果已有正在处理手势的视图，请执行正常的事件调度。不在执行辅助功能设置 if (intercepted || mFirstTouchTarget != null) &#123; ev.setTargetAccessibilityFocus(false); &#125; // 检查取消状态 final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; // 在子View没有设置请求父View不拦截分发时打上FLAG_SPLIT_MOTION_EVENTS标记，ViewGroup默认分割 如果启动则不同MotionEvent会打上不同手指Id标记位，如果MotionEvent对应不是本次触摸则复制一份MotionEvent打上新老ID标记在执行后续，详情参考ViewGroup.dispatchTransformedTouchEvent , TODO split为true为MotionEvent打上ID具体在native中这里暂时不深究 final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0; TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; if (!canceled &amp;&amp; !intercepted) &#123; // 如果事件的目标是可访问性焦点，我们会将其提供给具有辅助功能焦点的视图，如果它不处理它 //我们清除该标志并像往常一样将事件发送给所有子级。 //我们正在查找以可访问性为主的主机，以避免保持 //状态，因为这些事件非常罕见。 View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; // 从这里看到split判断，可以看到split是分别多指触摸的 if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; final int actionIndex = ev.getActionIndex(); // always 0 for down // 通过制定位置来记录触手指ID final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // 清除此指针ID的早期触摸目标，以防它们变得不同步。 removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123; final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); /** *所有子View首先按Z轴排序，然后按子绘图顺序排序（如果适用）。 *使用后必须清除此列表 *使用稳定的插入排序，对于ViewGroups来说通常是O（n） */ final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList(); // 是否按绘制顺序 final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; //根据子View Z轴绘制顺序查找处理本次触摸的View，并加入到Target链表中 for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); //取出转换顺序后的子View final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); // 循环查找辅助功能焦点View if (childWithAccessibilityFocus != null) &#123; if (childWithAccessibilityFocus != child) &#123; continue; &#125; // 恢复第一次索引继续 childWithAccessibilityFocus = null; i = childrenCount - 1; &#125; // canViewReceivePointerEvents判断View是否是可见状态，或者是否有动画，如果View是GONE或INVISIBLE则继续找下一个View // if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; //查找是否在TouchTarget链表中 newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; // 子View已经在其范围内接受了触摸。 // 除了正在处理的指针外，还给它新的手指ID newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; // TODO resetCancelNextUpFlag(child); //复制一份ev，分发触摸事件，如果child不为空发给child否则再次调用super.dispatchTouchEvent(event)，并返回是否处理 // PS这里View不会为NULL，所以应该不会调用super.dispatchTouchEvent(event) if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; //记录最后一次触摸Down事件 mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) &#123; // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) &#123; if (children[childIndex] == mChildren[j]) &#123; mLastTouchDownIndex = j; break; &#125; &#125; &#125; else &#123; mLastTouchDownIndex = childIndex; &#125; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); // 添加到Target链表，并把mFirstTouchTarget变为链表头 newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; // The accessibility focus didn't handle the event, so clear // the flag and do a normal dispatch to all children. ev.setTargetAccessibilityFocus(false); &#125; if (preorderedList != null) preorderedList.clear(); &#125; if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123; // Did not find a child to receive the event. // Assign the pointer to the least recently added target. newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) &#123; newTouchTarget = newTouchTarget.next; &#125; newTouchTarget.pointerIdBits |= idBitsToAssign; &#125; &#125; &#125; // 上面addTouchTarget方法对mFirstTouchTarget赋值 if (mFirstTouchTarget == null) &#123; // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); &#125; else &#123; // Dispatch to touch targets, excluding the new touch target if we already // dispatched to it. Cancel touch targets if necessary. TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) &#123; final TouchTarget next = target.next; //Down事件时true if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123; handled = true; &#125; else &#123; final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123; handled = true; &#125; if (cancelChild) &#123; if (predecessor == null) &#123; mFirstTouchTarget = next; &#125; else &#123; predecessor.next = next; &#125; target.recycle(); target = next; continue; &#125; &#125; predecessor = target; target = next; &#125; &#125; // 如果需要，更新手指up或cancel的触摸目标列表。 if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; resetTouchState(); &#125; else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123; final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); &#125; &#125; if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); &#125; return handled; &#125; 文章中有两端TODO 后续整明白在写上 暂时不影响整体流程阅读]]></content>
      <tags>
        <tag>Android触摸</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 触摸系列（一）View.onTouchEvent源码(28)分析]]></title>
    <url>%2F2019%2F08%2FAndroid%E8%A7%A6%E6%91%B8-Android-%E8%A7%A6%E6%91%B8%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89View-onTouchEvent%E6%BA%90%E7%A0%81-28-%E5%88%86%E6%9E%90.html</url>
    <content type="text"><![CDATA[一、前置知识16进制书写二进制标识View源码中很多16进制标识int如下： 12345678910...private static final int PFLAG_PREPRESSED = 0x02000000;/** * Indicates whether the view is temporarily detached. * * @hide */static final int PFLAG_CANCEL_NEXT_UP_EVENT = 0x04000000;... 16进制对应2进制（用于做标记）0x001 -&gt; 0000 0001 | 0x010 -&gt; 0001 00000x002 -&gt; 0000 0010 | 0x020 -&gt; 0010 00000x004 -&gt; 0000 0100 | 0x040 -&gt; 0100 00000x008 -&gt; 0000 1000 | 0x080 -&gt; 1000 0000通过这组数据规律不难看出，16进制书写二进制01指定位置标识的方便之处 flag中添加标识 1234567 .... case MotionEvent.ACTION_DOWN: if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) &#123; mPrivateFlags3 |= PFLAG3_FINGER_DOWN;//添加标识 &#125; mHasPerformedLongPress = false;.... flag中移除标识 123456private void removeTapCallback() &#123; if (mPendingCheckForTap != null) &#123; mPrivateFlags &amp;= ~PFLAG_PREPRESSED;//移除标识 removeCallbacks(mPendingCheckForTap); &#125; &#125; 二、开始View.onTouchEvent(MotionEvent)触摸源码分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167public boolean onTouchEvent(MotionEvent event) &#123; final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; final int action = event.getAction(); final boolean clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) //表示可以在上下文中单击此视图。当上下文可单击时，View通过通知 //OnContextClickListener来响应上下文单击（例如，主要触控笔按下或鼠标右键单击）。 || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE; //判断是否启动 if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125; mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; // A disabled view that is clickable still consumes the touch // events, it just doesn't respond to them. return clickable; &#125; //委托处理物理上在此视图中的触摸事件，但应由另一个视图处理。 if (mTouchDelegate != null) &#123; if (mTouchDelegate.onTouchEvent(event)) &#123; return true; &#125; &#125; //TOOLTIP表示此视图可以在悬停或长按时显示工具提示。 if (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123; switch (action) &#123; case MotionEvent.ACTION_UP: mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; if ((viewFlags &amp; TOOLTIP) == TOOLTIP) &#123; handleTooltipUp(); &#125; if (!clickable) &#123; removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; break; &#125; // 判断预按压对应在ACTION_DOWN添加标识 boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123; // 如果我们还没有它，请关注我们应该在 // 触摸模式 boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123; focusTaken = requestFocus(); &#125; if (prepressed) &#123; // 按钮在我们实际显示为按下之前被释放。让它现在显示按下的状态（在调度点击方法之前）以确保用户看到按下状态 setPressed(true, x, y); &#125; //在没有执行长按前 ， mIgnoreNextUpEvent是action是ACTION_BUTTON_RELEASE是赋值true源码在12666行 //ACTION_BUTTON_RELEASE此Action不是触摸事件，因此它被传递给 View#onGenericMotionEvent(MotionEvent)而不是 View#onTouchEvent(MotionEvent)。 if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123; // 在Handler里移除长按延时检测事件 removeLongPressCallback(); // 如果我们处于按下状态（别的View未获取焦点），则仅执行点击操作 if (!focusTaken) &#123; // 使用Runnable并发布此消息到Handler而不是直接调用performClick。这样可以在单击操作开始之前更新视图的其他可视状态。 if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123; performClickInternal(); &#125; &#125; &#125; //延时恢复点击状态 如按下时drawable变化 if (mUnsetPressedState == null) &#123; mUnsetPressedState = new UnsetPressedState(); &#125; if (prepressed) &#123; postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); &#125; else if (!post(mUnsetPressedState)) &#123; // If the post failed, unpress right now mUnsetPressedState.run(); &#125; //移除ACTION_DOWN添加的PFLAG_PREPRESSED标识 removeTapCallback(); &#125; mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_DOWN: //判断是否是触摸屏输入 if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) &#123; mPrivateFlags3 |= PFLAG3_FINGER_DOWN; &#125; //重置长按状态 mHasPerformedLongPress = false; //如果不能点击直接检查长按状态 if (!clickable) &#123; checkForLongClick(0, x, y); break; &#125; //鼠标左键右键按下时执行按钮操作 if (performButtonActionOnTouchDown(event)) &#123; break; &#125; // 向上遍历层次结构以确定我们是否在滚动容器内。 boolean isInScrollingContainer = isInScrollingContainer(); // 对于滚动容器内的视图，如果有滚动 // 将按下的反馈延迟一小段时间。 // 通过这一小段时间判断是否大于滚动伐值 // 伐值一般为ViewConfiguration.get(context).getScaledTouchSlop() if (isInScrollingContainer) &#123; mPrivateFlags |= PFLAG_PREPRESSED;//添加预按压标记 //mPendingCheckForTap是一个Runable run方法中去除PFLAG_PREPRESSED标识并执行setPressed(true, x, y);和checkForLongClick(ViewConfiguration.getTapTimeout(), x, y);（检查长按刨除预压占用时间) if (mPendingCheckForTap == null) &#123; mPendingCheckForTap = new CheckForTap(); &#125; mPendingCheckForTap.x = event.getX(); mPendingCheckForTap.y = event.getY(); postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); &#125; else &#123; // 不在滚动容器内，所以立即显示反馈 setPressed(true, x, y); checkForLongClick(0, x, y); &#125; break; case MotionEvent.ACTION_CANCEL: if (clickable) &#123; setPressed(false); &#125; removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; break; case MotionEvent.ACTION_MOVE: if (clickable) &#123; // 分发给背景（Drawable）触摸移动 drawableHotspotChanged(x, y); &#125; // 用于确定给定点（在本地坐标中）是否在视图内的实用方法，其中视图的区域由mTouchSlop扩展。 在处理触摸移动事件时调用此方法，以确定事件是否仍在视图中 if (!pointInView(x, y, mTouchSlop)) &#123; // 删除任何将来的长按/点击检查 removeTapCallback(); removeLongPressCallback(); if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125; mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; &#125; break; &#125; return true; &#125; return false; &#125;]]></content>
      <tags>
        <tag>Android触摸</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程启动与停止]]></title>
    <url>%2F2019%2F08%2F%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E5%90%AF%E5%8A%A8%E4%B8%8E%E5%81%9C%E6%AD%A2.html</url>
    <content type="text"><![CDATA[一、线程启动 直接启动 123456new Thread(new Runnable() &#123; @Override public void run() &#123; ... &#125; &#125;).start(); 线程池 1234567891011121314151617181920212223242526272829303132333435363738394041Executor threadPoolExecutor = Executors.newSingleThreadExecutor();threadPoolExecutor.execute(new Runnable() &#123; @Override public void run() &#123; ... &#125;&#125;);Future&lt;?&gt; submit = threadPoolExecutor.submit(new Callable&lt;Object&gt;() &#123; @Override public Object call() throws Exception &#123; return null; &#125;&#125;);/** * 阻塞当前线程LockSupport.parkNanos(this, nanos)或者LockSupport.park(Object blocker) * 解锁阻塞LockSupport.unpark(Thread thread) * 在java6之后在park系列方法新增加了入参Object blocker，用于标识阻塞对象，该对象主要用于问题排查和系统监控。 */try &#123; Object o2 = submit.get();//得到返回值会阻塞当前线程&#125; catch (InterruptedException e) &#123;//待会讲异常 e.printStackTrace();&#125; catch (ExecutionException e) &#123; e.printStackTrace();&#125;/** * 内部通过Executors.callable(runnable, result);包装成RunnableAdapter返回一个被设置为final的result */submit = threadPoolExecutor.submit(new Runnable() &#123; @Override public void run() &#123; &#125;&#125;);try &#123; Object o2 = submit.get();&#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125; catch (ExecutionException e) &#123; e.printStackTrace();&#125; 二、线程停止Ⅰ 线程终止 直接停止使用stop方法，暴力终止。 可能使一些清理性的工作得不到完成。 可能对锁定的内容进行解锁，容易造成数据不同步的问题。 使用自定义标识终止 标识同步需要解决，否则可能根本停不下来 解决类似如Thread.sleep(100)浪费时间问题 使用Thread.interrupt()方法中断线程。 java原生添加的中断标识并不会真正中断线程，需要自己手动使用thread.isInterrupted()或Thread.interrupted();判断 直接终止join(),sleep(),wait()等一系列等待方法并抛出InterruptedException异常。Future.get()并不会马上停止而是等待LockSupport.unpark(Thread thread)调用之后判断标识抛出异常 如果在{@link java.nio.channels.InterruptibleChannel InterruptibleChannel} 的I / O操作中阻塞了该线程，那么通道将被关闭，线程的中断*状态将被设置，线程将收到{ @link java.nio.channels.ClosedByInterruptException}。 Thread.interrupted();方法会清理Thread.interrupt()设置的中断标识为不中断 收到InterruptedException异常之后做线程清理工作 Ⅱ 线程池的终止 线程池中单次Task停止使用Future..cancel(boolean mayInterruptIfRunning)方法，启动mayInterruptIfRunning参数为true时会调用Thread.interrupt() ExecutorService.shutdown()有序关闭，其中之前提交的任务继续被执行，但不会接受任何新任务。如果继续submit()添加任务则抛出RejectedExecutionException异常不会执行新的任务。 List&lt;Runnable&gt; runnables = executorService.shutdownNow();立即停止，正在执行的会使用Thread.interrupt()修改终止，还未被执行的runnable返回。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495class TestExecuteService &#123; public static void main(String[] args) &#123; ExecutorService executorService = Executors.newSingleThreadExecutor(); for (int i = 1; i &lt;= 10; i++) &#123; executorService.submit(new TestRunnable(i)); &#125; try &#123; Thread.sleep(100 * 5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; /** * 输出 * +++++++++开始执行(1) * ---------执行结束(1) * +++++++++开始执行(2) * ---------执行结束(2) * +++++++++开始执行(3) * Exception in thread "main" java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@5e2de80c rejected from java.util.concurrent.ThreadPoolExecutor@1d44bcfa[Shutting down, pool size = 1, active threads = 1, queued tasks = 7, completed tasks = 2] * at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2063) * at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:830) * at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1379) * at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:112) * at java.util.concurrent.Executors$DelegatedExecutorService.submit(Executors.java:678) * at com.TestExecuteService.main(TestExecuteService.java:20) * ---------执行结束(3) * +++++++++开始执行(4) * ---------执行结束(4) * +++++++++开始执行(5) * ---------执行结束(5) * +++++++++开始执行(6) * ---------执行结束(6) * +++++++++开始执行(7) * ---------执行结束(7) * +++++++++开始执行(8) * ---------执行结束(8) * +++++++++开始执行(9) * ---------执行结束(9) * +++++++++开始执行(10) * ---------执行结束(10) */// executorService.shutdown();// executorService.submit(new TestRunnable(11)); /** * 输出 * +++++++++开始执行(1) * ---------执行结束(1) * +++++++++开始执行(2) * ---------执行结束(2) * +++++++++开始执行(3) * --------------------------- * +++++++++开始执行(4) * ******-------*******中断了:3 * ---------执行结束(4) * +++++++++开始执行(5) * ---------执行结束(5) * +++++++++开始执行(6) * ---------执行结束(6) * +++++++++开始执行(7) * ---------执行结束(7) * +++++++++开始执行(8) * ---------执行结束(8) * +++++++++开始执行(9) * ---------执行结束(9) * +++++++++开始执行(10) * ---------执行结束(10) */ List&lt;Runnable&gt; runnables = executorService.shutdownNow(); System.out.println("---------------------------"); for (Runnable runnable : runnables) &#123; runnable.run(); &#125; &#125; public static class TestRunnable implements Runnable &#123; final int index; public TestRunnable(int index) &#123; this.index = index; &#125; @Override public void run() &#123; try &#123; System.out.println("+++++++++开始执行(" + index + ")"); Thread.sleep(100 * index); System.out.println("---------执行结束(" + index + ")"); &#125; catch (InterruptedException e) &#123; System.out.println("******-------*******中断了:" + index); &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改并编译framework]]></title>
    <url>%2F2019%2F06%2Fframework-%E4%BF%AE%E6%94%B9%E5%B9%B6%E7%BC%96%E8%AF%91framework.html</url>
    <content type="text"><![CDATA[关闭dex优化否则，编译完framework之后 push 不生效 在./build/core/dex_preopt.mk文件中修改DEX_PREOPT_DEFAULT的值为false,修改后如下： 12# The default value for LOCAL_DEX_PREOPTDEX_PREOPT_DEFAULT ?= false 搜索GLOBAL_DEXPREOPT_FLAGS :=，在这行之后添加WITH_DEXPREOPT := false 12GLOBAL_DEXPREOPT_FLAGS :=WITH_DEXPREOPT := false 如果之前编译过源码需要删除out目录重新编译,没编译过的直接跳过 1rm -rf out/ 修改Activity源码 123456789101112131415public class Activity extends ContextThemeWrapper implements LayoutInflater.Factory2, Window.Callback, KeyEvent.Callback, OnCreateContextMenuListener, ComponentCallbacks2, Window.OnWindowDismissedCallback, WindowControllerCallback &#123; private static final String TAG = "Activity"; private static final boolean DEBUG_LIFECYCLE = false; /** Standard activity result: operation canceled. */ public static final int RESULT_CANCELED = 0; /** Standard activity result: operation succeeded. */ public static final int RESULT_OK = -1; /** Start of user-defined activity results. */ public static final int RESULT_FIRST_USER = 1;... 这里修改DEBUG_LIFECYCLE为true 123456protected void onCreate(@Nullable Bundle savedInstanceState) &#123; if (DEBUG_LIFECYCLE) Slog.v(TAG, "onCreate " + this + ": " + savedInstanceState); if (mLastNonConfigurationInstances != null) &#123; mFragments.restoreLoaderNonConfig(mLastNonConfigurationInstances.loaders); &#125;... DEBUG_LIFECYCLE控制声明周期log 使用make framewok重新编译framewoke,如果之前没有编译过则需要完全编译使用make -j8 提示: ​ 编译前,需要source ./build/envsetup.sh和lunch流程,不懂可以看我的上篇编译android8-1源码并刷入Pixel 刷入并重启framework层 1234#刷入framework.jaradb push out/target/product/sailfish/system/framework/framework.jar /system/framework/#重启frameworkadb shell stop;start]]></content>
      <tags>
        <tag>framework层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译android8.1源码并刷入Pixel]]></title>
    <url>%2F2019%2F06%2Fframework-%E7%BC%96%E8%AF%91android8-1%E6%BA%90%E7%A0%81%E5%B9%B6%E5%88%B7%E5%85%A5Pixel.html</url>
    <content type="text"><![CDATA[环境准备 Ubuntu 19.04 Pixel手机 android-8.1.0源码 源码下载 首先确定源码git的分支，通过访问https://source.android.com/setup/start/build-numbers查询 这里看到支持Pixel的8.1.0分支最后一版为android-8.1.0_r38（细分版本：OPM4.171019.021.P1）细分版本在下载驱动时用到。 确定完分支，安装repo工具准备开始下载（repo 是一款工具，可让您在 Android 环境中更轻松地使用 Git。要详细了解 repo，请参阅开发部分。），安装命令如下： 12curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repochmod a+x ~/bin/repo 选取国内源开始下载，不推荐google源你懂的。 清华提供的镜像源（https://aosp.tuna.tsinghua.edu.cn/platform/manifest） 中国科学技术大学的镜像源（git://mirrors.ustc.edu.cn/aosp/platform/manifest） 1234567# 建立文件夹mkdir android-8.1.0_r38cd android-8.1.0_r38# repo init推荐使用-b 分支标签、--depth=1和--platform=auto这几个选项加快速度repo init -u git://mirrors.ustc.edu.cn/aosp/platform/manifest -b android-8.1.0_r38 --depth=1 --platform=auto# repo sync推荐使用--current-branch选项加快速度，中科大限制了每个用户最多使用4线程，因此指定-j8选项并不能提高下载速度，所以使用j4 4线程下载。repo sync -f -j4 --current-branch 因为这一步才是真正的从服务器把源码下拉的过程，repo相当与是执行了多个git，期间有一个git出问题，比如网络卡神马的就中断，然后就是重复repo sync。。。。，这里防止多次失败笔者改用一个脚本去 执行repo sunc，在android-8.1.0_r38下建立一个down.sh文件内容如下： 12345678# !/bin/bashecho ¨================start repo sync===============¨repo sync -f -j4 --current-branchwhile [ $? == 1 ]; doecho ¨================sync failed, re-sync again=============¨sleep 3repo sync -f -j4 --current-branchdone 保存完，执行如下开始下载。 12chmod a+x down.sh./down.sh 下载较慢，耐心等待。所有源码下载完毕，其余文件夹就会出现。 下载驱动打开https://developers.google.com/android/drivers,搜索细分版本（OPM4.171019.021.P1）找到驱动 点击Link下载这两个文件并解压，得到两个脚本如下： 重复执行两个脚本，两个脚本都是一路回车到最后根据提示输入I ACCEPT同意协议 注：一路回车到最后最好一下以下按，按多了直接结束脚本了。 脚本执行完之后得到vendor，移动vendor文件夹到源码目录android-8.1.0_r38下。 备份源码 1234#切换到android-8.1.0_r38,删除.reporm -rf .repo#切换到android-8.1.0_r38父目录tar -zcvf android-8.1.0_r38.tar.gz android-8.1.0_r38/ 编译 安装依赖 12345678910sudo apt-get install -y git flex bison gperf build-essential libncurses5-dev:i386 sudo apt-get install libx11-dev:i386 libreadline6-dev:i386 libgl1-mesa-dev g++-multilib sudo apt-get install tofrodos python-markdown libxml2-utils xsltproc zlib1g-dev:i386 sudo apt-get install dpkg-dev libsdl1.2-dev libesd0-devsudo apt-get install git-core gnupg flex bison gperf build-essential sudo apt-get install zip curl zlib1g-dev gcc-multilib g++-multilib sudo apt-get install libc6-dev-i386 sudo apt-get install lib32ncurses5-dev x11proto-core-dev libx11-dev sudo apt-get install lib32z-dev ccachesudo apt-get install libgl1-mesa-dev libxml2-utils xsltproc unzip m4 笔者安装以来过程中遇到libncurses5-dev:i386和lib32ncurses5-dev版本安装过高问题 使用如下命令根据提示解决依赖版本问题 12sudo aptitude install libncurses5-dev:i386sudo aptitude install lib32ncurses5-dev 安装Open JDK8，并配置环境变量。 12345678910111213#安装jdk8sudo apt-get install openjdk-8-jdk #配置环境变量gedit ~/.bashrc# 在bashrc末尾追加export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH#去除所有本地化的设置，让命令能正确执行 最好加上这句不加有坑export LC_ALL=C#别忘了source下source ~/.bashrc 开始编译 123456#导入编译Android源码所需的环境变量。这里面包含lunch命令环境变量source build/envsetup.sh#选择编译类型，sailfish是pixel手机代号，eng: 工程机，user:最终用户机userdebug:调试测试机tests:测试机lunch aosp_sailfish-userdebug#使用make开始编译，使用j8 8线程make clean; make -j8 一般两小时编译完，编译完建议重启 莫名的ubuntu很卡 输入手机 12345678#重启需要重新配置Android源码所需的环境变量source build/envsetup.sh#还需要重新确定版本lunch aosp_sailfish-userdebug#插入数据线，重启手机进入bootloaderadb reboot bootloader#开始刷入fastboot flashall -w 这里如果手机版本比8.1高，可能刷入后，手机进入不了系统 这里笔者是重新从官方下载8.1（细分版本：OPM4.171019.021.P1）镜像刷入之后正常启动系统，重新执行fastboot flashall -w刷入正常启动 最后展示一张成功启动进入系统中关于中的编译信息 参考seekting博客中两篇，如下： nexus6p刷机源码系统 编译android9并刷到pixl里]]></content>
      <tags>
        <tag>framework层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava之map转换]]></title>
    <url>%2F2019%2F03%2F%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-RxJava%E4%B9%8Bmap%E8%BD%AC%E6%8D%A2%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"><![CDATA[首先是Map代码调用 把222转换为666 StartOnSubscribe 被订阅者 Func1 转换func ResultSubscriber 订阅者 123456789101112131415161718192021222324252627282930public class TestActivity extends AppCompatActivity &#123; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Observable.create(new StartOnSubscribe()).map(new Func1&lt;Integer, Integer&gt;() &#123; @Override public Integer call(Integer integer) &#123; return 666; &#125; &#125;).subscribe(new ResultSubscriber()); &#125; public static class StartOnSubscribe implements Observable.OnSubscribe&lt;Integer&gt; &#123; @Override public void call(Subscriber&lt;? super Integer&gt; subscriber) &#123; subscriber.onNext(222); &#125; &#125; public static class ResultSubscriber&lt;T&gt; extends Subscriber&lt;T&gt; &#123; @Override public void onCompleted() &#123;&#125; @Override public void onError(Throwable e) &#123;&#125; @Override public void onNext(T integer) &#123; System.out.println(integer); &#125; &#125;&#125; 然后看Observable的map方法 123public final &lt;R&gt; Observable&lt;R&gt; map(Func1&lt;? super T, ? extends R&gt; func) &#123; return lift(new OperatorMap&lt;T, R&gt;(func));&#125; 封装了一个OperatorMap,而OperatorMap实现Operator其实是一个Func1的实现,其中构造方法里又传入一个Func1(这个有点像使用变换过的装饰着模式),同时还含有一个call方法返回内部定义的一个子类MapSubscriber 123456789public final class OperatorMap&lt;T, R&gt; implements Operator&lt;R, T&gt; &#123;...省略代码 @Override public Subscriber&lt;? super T&gt; call(final Subscriber&lt;? super R&gt; o) &#123; MapSubscriber&lt;T, R&gt; parent = new MapSubscriber&lt;T, R&gt;(o, transformer); o.add(parent); return parent; &#125;...省略代码 MapSubscriber一个订阅者在这个订阅者的内部onNext调用map方法传入的Func1执行map转换 MapSubscriber其实是最后传入的订阅者ResultSubscriber的一个代理类 1234567891011121314151617181920212223242526272829303132static final class MapSubscriber&lt;T, R&gt; extends Subscriber&lt;T&gt; &#123;...省略代码 @Override public void onNext(T t) &#123; R result; try &#123; result = mapper.call(t);//此处mapper就是map方法传入的Func1(例子中222变成666的方法) &#125; catch (Throwable ex) &#123; Exceptions.throwIfFatal(ex); unsubscribe(); onError(OnErrorThrowable.addValueAsLastCause(ex, t)); return; &#125; actual.onNext(result);//这里actual是OperatorMap中call方法传入的父订阅者(ResultSubscriber) &#125; @Override public void onError(Throwable e) &#123; ...省略代码 actual.onError(e); &#125; @Override public void onCompleted() &#123; ...省略代码 actual.onCompleted(); &#125;...省略代码 &#125; 看完OperatorMap继续往下看map方法中调用的lift方法 123public final &lt;R&gt; Observable&lt;R&gt; lift(final Operator&lt;? extends R, ? super T&gt; operator) &#123; return new Observable&lt;R&gt;(new OnSubscribeLift&lt;T, R&gt;(onSubscribe, operator));&#125; 这里又是一个代理模式,OnSubscribeLift代理原本的onSubscribe对象来完成“订阅操作(具体流程比较复杂请参看源码)” “订阅操作”简单说就.subscribe(new ResultSubscriber())之后执行的一系列方法大致分可简化为三步。 首先Subscriber的onStart() 然后是OnSubscribe的call方法 call方法中又相继执行Subscriber的onNext,onError,onCompleted方法 这里一个弯就是原本的Observable.create(new StartOnSubscribe())产生的Observable被替换成lift方法new出来的Observable给替换了,原本的Observable并没有执行“订阅操作” 过了这个弯就知道了OnSubscribeLift这个代理类执行了“订阅操作”,具体看OnSubscribeLift中都干了什么 1234567891011121314151617181920public final class OnSubscribeLift&lt;T, R&gt; implements OnSubscribe&lt;R&gt; &#123;...省略代码 @Override public void call(Subscriber&lt;? super R&gt; o) &#123; try &#123; //operator是构造方法传入的Func1的代理类 //hook.onLift方法把传入的operator返回也就是调用operator的call方法返回Subscriber(MapSubscriber) Subscriber&lt;? super T&gt; st = hook.onLift(operator).call(o); try &#123; st.onStart(); //parent是构造方法传入的最开始Observable中OnSubscribe也就是StartOnSubscribe parent.call(st); &#125; catch (Throwable e) &#123; ...省略代码 &#125; &#125; catch (Throwable e) &#123; ...省略代码 &#125; &#125;&#125; StartOnSubscribe的call方法在这里被执行了,在call中调用st的onNext传入222,也就是调用MapSubscriber的onNext方法 1234567891011121314151617181920212223242526272829303132static final class MapSubscriber&lt;T, R&gt; extends Subscriber&lt;T&gt; &#123;...省略代码 @Override public void onNext(T t) &#123; R result; try &#123; result = mapper.call(t);//此处mapper就是map方法传入的Func1(例子中222变成666的方法) &#125; catch (Throwable ex) &#123; Exceptions.throwIfFatal(ex); unsubscribe(); onError(OnErrorThrowable.addValueAsLastCause(ex, t)); return; &#125; actual.onNext(result);//这里actual是OperatorMap中call方法传入的父订阅者(ResultSubscriber) &#125; @Override public void onError(Throwable e) &#123; ...省略代码 actual.onError(e); &#125; @Override public void onCompleted() &#123; ...省略代码 actual.onCompleted(); &#125;...省略代码 &#125; 再次看MapSubscriber的onNext执行过程,先转换然后调用被代理的真实Subscriber也就是ResultSubscriber的onNext方法 到这里就看完了整个过程还是比较复杂的。使用了变种装饰者模式与代理模式(PS:这两个模式不太好区分结构上差别不大多在用法上不同) 补充lift方法中为直接重新创建一个Observable未来有可能会改进,如果T与R类型一样,直接修改Observable的onSubscribe引用为新的OnSubscribeLift返回自身,可惜java没有判断泛型T与R类型上是否相同,只能期盼未来了]]></content>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[针对EditText的Markdown链接式文本编辑]]></title>
    <url>%2F2019%2F03%2F%E8%87%AA%E5%AE%9A%E4%B9%89View-%E9%92%88%E5%AF%B9EditText%E7%9A%84Markdown%E9%93%BE%E6%8E%A5%E5%BC%8F%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91.html</url>
    <content type="text"><![CDATA[静态效果图: 最终转换为文本Markdown格式上传服务器:发一个帖子连接,带一个,点击[连接2](http://www.cmcm.com/zh-cn/)查看详情 效果演示: 1. 光标处插入1234567891011121314151617181920212223242526272829303132333435363738public class LinkedEditText extends AppCompatEditText &#123; ...省略代码 public void insertLinked(String name, String url) &#123; insertMDLinked(getSelectionEnd(), name, url, convertMDLinked(name, url)); &#125; @NonNull private String convertMDLinked(String name, String url) &#123; StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append('['); stringBuilder.append(name); stringBuilder.append(']'); stringBuilder.append('('); stringBuilder.append(url); stringBuilder.append(')'); return stringBuilder.toString(); &#125; private void insertMDLinked(int where, String name, String url, String mdLinked) &#123; Editable text = getText(); LinkeSpan span = new LinkeSpan(getContext(),name, url, mdLinked); text.insert(where, name); /** * Spans of type SPAN_EXCLUSIVE_EXCLUSIVE do not expand * to include text inserted at either their starting or ending point. * They can never have a length of 0 and are automatically removed * from the buffer if all the text they cover is removed. * SPAN_EXCLUSIVE_EXCLUSIVE类型的跨度不会展开 * 以包括在其起点或终点插入的文本。 * 它们的长度永远不会为0，如果删除了所有文本， * 它们将自动从缓冲区中删除。 */ text.setSpan(span, where, where + name.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); //-----------------------下面这行后面介绍---------------------------------- text.setSpan(new ReplacementSelectSpan(), where, where + name.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); &#125; ...省略代码&#125; 2. LinkeSpan实现12345678910111213141516171819private static class LinkeSpan extends ReplacementSpan implements Comparable&lt;LinkeSpan&gt; &#123; ...省略代码 @Override public int getSize(@NonNull Paint paint, CharSequence text, int start, int end, @Nullable Paint.FontMetricsInt fm) &#123; return (int) (dp32 + dp4 + paint.measureText(urlName) + 0.5F); &#125; @Override public void draw(@NonNull Canvas canvas, CharSequence text, int start, int end, float x, int top, int y, int bottom, @NonNull Paint paint) &#123; sDrawableLiked.setBounds((int) (x + dp8), top + ((bottom - top - sDrawableLiked.getMinimumHeight()) &gt;&gt; 1), (int) (x + dp16 + dp8), bottom); sDrawableLiked.draw(canvas); int color = paint.getColor(); paint.setColor(0xFF687FFF); canvas.drawText(this.urlName, x + dp32, (float) y, paint); paint.setColor(color); &#125; ...省略代码 &#125; 3. 转换为Markdown连接式文本123456789101112131415161718192021222324252627282930313233343536public String toMDString() &#123; Editable text = getText(); StringBuffer stringBuffer = new StringBuffer(); //获取LinkeSpan是按照加入顺序排序,并非文本中位置顺序 LinkeSpan[] linkes = text.getSpans(0, text.length(), LinkeSpan.class); for (LinkeSpan linkeSpan : linkes) &#123; linkeSpan.index = text.getSpanStart(linkeSpan); &#125; Arrays.sort(linkes);//文本中位置顺序 char[] tmp; int start = 0; for (LinkeSpan linke : linkes) &#123; int charCount = linke.index - start; int linkeNameSize = linke.urlName.length(); if (charCount &gt; 0) &#123; tmp = new char[charCount]; text.getChars(start, linke.index, tmp, 0); stringBuffer.append(tmp); stringBuffer.append(linke.toString()); start = linke.index + linkeNameSize; &#125; else if (charCount == 0) &#123; stringBuffer.append(linke.toString()); start += linkeNameSize; &#125; &#125; //补足剩余字符 int length = text.length(); if (start &lt; length) &#123; tmp = new char[length - start]; text.getChars(start, length, tmp, 0); stringBuffer.append(tmp); &#125; return stringBuffer.toString(); &#125; 4. Markdown连接回转显示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class MarkDownURLMatcher &#123; private final static String URL_NAME = "[\\w \\(\\)\\t#&amp;%$@\\u4e00-\\u9fa5]*"; private final static String HTTP = "(https?|ftp|file)://([\\w-]+\\.)+[\\w-]+(/[\\w- ./?%&amp;=]*)?"; private final static String MATCHER = "\\[(" + URL_NAME + ")\\]\\((" + HTTP + ")\\)"; private final static Pattern MD_URL_MATCHER = Pattern.compile(MATCHER); ...省略代码 /** * 收集文本中markdown链接 转换为SpannerString * 格式:[xxx](xxxx) */ private static final SpannableStringBuilder convertTextLinks(String text) &#123; Matcher m = MD_URL_MATCHER.matcher(text); SpannableStringBuilder spannableStringBuilder = new SpannableStringBuilder(); int lastIndex = 0; while (m.find()) &#123; String name = m.group(1); String url = m.group(2); if (name == null) &#123; name = ""; &#125; lastIndex = convertLinkedSpan(text, m, spannableStringBuilder, lastIndex, name, url); &#125; if (lastIndex == 0) &#123; spannableStringBuilder.append(text); &#125; else if (text.length() &gt; lastIndex) &#123; appendEndText(spannableStringBuilder, text.substring(lastIndex, text.length())); &#125; else &#123; spannableStringBuilder.append(" ");//防止点击事件延长至整行 &#125; return spannableStringBuilder; &#125; private static int convertLinkedSpan(String text, Matcher m, SpannableStringBuilder spannableStringBuilder, int lastIndex, String name, String url) &#123; int start = m.start(); String substring = text.substring(lastIndex, start); spannableStringBuilder.append(substring); int urlTextStart = spannableStringBuilder.length(); spannableStringBuilder.append(name); //ClickLinkeSpan仿照LinkeSpan并添加Click实现 spannableStringBuilder.setSpan(new ClickLinkeSpan(name, url), urlTextStart, urlTextStart + name.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); lastIndex = m.end(); return lastIndex; &#125; private static class ClickLinkeSpan extends ReplacementSpan implements SpanClickable, NoCopySpan &#123; private String url; ...省略代码 @Override public int getSize(@NonNull Paint paint, CharSequence text, int start, int end, @Nullable Paint.FontMetricsInt fm) &#123; ...省略代码 &#125; @Override public void draw(@NonNull Canvas canvas, CharSequence text, int start, int end, float x, int top, int y, int bottom, @NonNull Paint paint) &#123; ...省略代码 &#125; @Override public void onClick(View widget) &#123; Uri uri = Uri.parse(url); Context context = widget.getContext(); Intent intent = new Intent(Intent.ACTION_VIEW, uri); intent.putExtra(Browser.EXTRA_APPLICATION_ID, context.getPackageName()); try &#123; context.startActivity(intent); &#125; catch (ActivityNotFoundException e) &#123; Log.w("LinkeSpan", "Actvity was not found for intent, " + intent.toString()); &#125; &#125; &#125;&#125; 5. 点击效果实现(没有使用TextView的setMovementMethod()添加MovementMethod实现)1234567891011121314151617181920212223242526272829303132333435363738394041public interface SpanClickable &#123; void onClick(View widget);&#125;public static class ClickableSpanListener implements View.OnTouchListener &#123; private static ClickableSpanListener instance = new ClickableSpanListener(); public static ClickableSpanListener getInstantce() &#123; return instance; &#125; @Override public boolean onTouch(View view, MotionEvent event) &#123; boolean ret = false; if (view instanceof TextView) &#123; TextView textView = (TextView) view; int action = event.getAction(); if (action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_DOWN) &#123; CharSequence text = textView.getText(); if (text instanceof Spanned) &#123; int x = (int) event.getX(); int y = (int) event.getY(); x -= textView.getTotalPaddingLeft(); y -= textView.getTotalPaddingTop(); x += textView.getScrollX(); y += textView.getScrollY(); Layout layout = textView.getLayout(); int line = layout.getLineForVertical(y); int off = layout.getOffsetForHorizontal(line, x); Spanned spannable = (Spanned) text; SpanClickable[] link = spannable.getSpans(off, off, SpanClickable.class); if (link != null &amp;&amp; link.length &gt; 0 &amp;&amp; link[0] != null) &#123; if (action == MotionEvent.ACTION_UP) &#123; link[0].onClick(textView); &#125; ret = true; &#125; &#125; &#125; &#125; return ret; &#125; &#125; 6.开发中遇到的棘手问题 选择BUG BUG展示: 通过代码跟踪最终找到选择是通过android.widget.Editor的private boolean selectCurrentWord()方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667private boolean selectCurrentWord() &#123; ...省略代码 // If a URLSpan (web address, email, phone...) is found at that position, select it. URLSpan[] urlSpans = ((Spanned) mTextView.getText()). getSpans(minOffset, maxOffset, URLSpan.class); if (urlSpans.length &gt;= 1) &#123;//这里有限判断URLSpan如果有有限选中全部文本 URLSpan urlSpan = urlSpans[0]; selectionStart = ((Spanned) mTextView.getText()).getSpanStart(urlSpan); selectionEnd = ((Spanned) mTextView.getText()).getSpanEnd(urlSpan); &#125; else &#123;//选择单词 数字 词语 // FIXME - We should check if there's a LocaleSpan in the text, this may be // something we should try handling or checking for. final WordIterator wordIterator = getWordIterator(); wordIterator.setCharSequence(mTextView.getText(), minOffset, maxOffset); selectionStart = wordIterator.getBeginning(minOffset); selectionEnd = wordIterator.getEnd(maxOffset); if (selectionStart == BreakIterator.DONE || selectionEnd == BreakIterator.DONE || selectionStart == selectionEnd) &#123; // Possible when the word iterator does not properly handle the text's language long range = getCharClusterRange(minOffset); selectionStart = TextUtils.unpackRangeStartFromLong(range); selectionEnd = TextUtils.unpackRangeEndFromLong(range); &#125; &#125; //设置选择文本 Selection.setSelection((Spannable) mTextView.getText(), selectionStart, selectionEnd); return selectionEnd &gt; selectionStart;&#125;//URLSpan源码public class URLSpan extends ClickableSpan implements ParcelablParcelableSpaneSpan &#123; ...省略代码 /** @hide */ public int getSpanTypeIdInternal() &#123; return TextUtils.URL_SPAN; &#125; @Override public void onClick(View widget) &#123; Uri uri = Uri.parse(getURL()); Context context = widget.getContext(); Intent intent = new Intent(Intent.ACTION_VIEW, uri); intent.putExtra(Browser.EXTRA_APPLICATION_ID, context.getPackageName()); try &#123; context.startActivity(intent); &#125; catch (ActivityNotFoundException e) &#123; Log.w("URLSpan", "Actvity was not found for intent, " + intent.toString()); &#125; &#125;&#125;...省略代码private void insertMDLinked(int where, String name, String url, String mdLinked) &#123; Editable text = getText(); LinkeSpan span = new LinkeSpan(getContext(),name, url, mdLinked); text.insert(where, name); text.setSpan(span, where, where + name.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); //同一位置设置两种Span text.setSpan(new ReplacementSelectSpan(), where, where + name.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); &#125;...省略代码 复制BUG解决 BUG展示: 前面通过URLSpan解决选择问题同时引入新问题URLSpan实现ParcelableSpan可被序列化复制,并且复制结果不允许自定义 1234567891011121314151617181920212223242526272829303132333435/** * A special kind of Parcelable for objects that will serve as text spans. * This can only be used by code in the framework; it is not intended for * applications to implement their own Parcelable spans. * 对象的一种特殊的Parcelable，用作文本跨度。 * 这只能由框架中的代码使用;, 它不适用于 * 应用程序来实现自己的 * Parcelable跨度。 */public interface ParcelableSpan extends Parcelable &#123; /** * Return a special type identifier for this span class. * 返回此span类的特殊类型标识符。 */ int getSpanTypeId(); /** * Internal implementation of &#123;@link #getSpanTypeId()&#125; that is not meant to * be overridden outside of the framework. * &#123;@link #getSpanTypeId（）&#125;的内部实现，并不意味着在框架之外被覆盖。 * * @hide */ int getSpanTypeIdInternal(); /** * Internal implementation of &#123;@link Parcelable#writeToParcel(Parcel, int)&#125; * that is not meant to be overridden outside of the framework. * &#123;@link Parcelable＃writeToParcel（Parcel，int）&#125; * 的内部实现，并不意味着在框架之外被覆盖。 * * @hide */ void writeToParcelInternal(Parcel dest, int flags);&#125; 最终通过查看系统其Span实现找到NoCopySpan接口进行实现避免被复制代码如下: 12345678910111213private static class ReplacementSelectSpan extends URLSpan implements NoCopySpan &#123; public ReplacementSelectSpan() &#123; super(""); &#125; @Override public void updateDrawState(TextPaint ds) &#123; &#125; @Override public void onClick(View widget) &#123; &#125; &#125; 源码:https://github.com/Android-Mainli/AndroidDemo2018]]></content>
      <tags>
        <tag>自定义View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有趣的头像(hash值生成头像)]]></title>
    <url>%2F2019%2F03%2F%E5%85%B6%E4%BB%96-%E6%9C%89%E8%B6%A3%E7%9A%84%E5%A4%B4%E5%83%8F-hash%E5%80%BC%E7%94%9F%E6%88%90%E5%A4%B4%E5%83%8F.html</url>
    <content type="text"><![CDATA[HTTP 请求 http://www.gravatar.com/avatar/{hash}?s=256&amp;d=identicon hash：生成一个随机数填充 s：尺寸，像素为单位 d：风格，目前可选 identicon、monsterid、wavatar、retro、robohash 等 来源]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读AliJava规范手册随笔]]></title>
    <url>%2F2019%2F03%2F%E9%9A%8F%E7%AC%94-%E8%AF%BBAliJava%E8%A7%84%E8%8C%83%E6%89%8B%E5%86%8C%E9%9A%8F%E7%AC%94.html</url>
    <content type="text"><![CDATA[(一)命名 命名风格 风格 【强制】类名使用 UpperCamelCase 风格，但以下情形例外： DO / BO / DTO / VO / AO /PO 等。正例： MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion反例： macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion 【强制】方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。正例： localValue / getHttpMessage() / inputUserId 【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。正例： MAX _ STOCK _ COUNT反例： MAX _ COUNT 【强制】抽象类命名使用 Abstract 或 Base 开头 ； 异常类命名使用 Exception 结尾 ； 测试类命名以它要测试的类名开始，以 Test 结尾。 【强制】 POJO 类中布尔类型的变量，都不要加 is 前缀 ，否则部分框架解析会引起序列化错误。反例：定义为基本数据类型 Boolean isDeleted； 的属性，它的方法也是 isDeleted() ， RPC框架在反向解析的时候，“误以为”对应的属性名称是 deleted ，导致属性获取不到，进而抛出异常。 【推荐】如果模块、接口、类、方法使用了设计模式，在命名时体现出具体模式。说明：将设计模式体现在名字中，有利于阅读者快速理解架构设计理念。正例：public class OrderFactory;public class LoginProxy;public class ResourceObserver;]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读AliAndroid开发手册随笔]]></title>
    <url>%2F2019%2F03%2F%E9%9A%8F%E7%AC%94-%E8%AF%BBAliAndroid%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%E9%9A%8F%E7%AC%94.html</url>
    <content type="text"><![CDATA[三、Android基本组件 Activity 间的数据通信，对于数据量比较大的，避免使用 Intent + Parcelable的方式，可以考虑 EventBus 等替代方案，以免造成 TransactionTooLargeException。 Activity 间通过隐式 Intent 的跳转，在发出 Intent 之前必须通过 resolveActivity检查，避免找不到合适的调用组件，造成 ActivityNotFoundException 的异常。 123456789101112131415public void viewUrl(String url, String mimeType) &#123; Intent intent = new Intent(Intent.ACTION_VIEW); intent.setDataAndType(Uri.parse(url), mimeType); if (getPackageManager().resolveActivity(intent, PackageManager.MATCH_DEFAULT_ ONLY) != null) &#123; try &#123; startActivity(intent); &#125; catch (ActivityNotFoundException e) &#123; if (Config.LOGD) &#123; Log.d(LOGTAG, "activity not found for " + mimeType + " over "+Uri.parse(url).getScheme(), e); &#125; &#125; &#125; &#125; 避免在 Service#onStartCommand()/onBind()方法中执行耗时操作，如果确实有需求，应改用 IntentService 或采用其他异步机制完成。 避免在 BroadcastReceiver#onReceive()中执行耗时操作，如果有耗时工作，应该创建 IntentService 完成，而不应该在 BroadcastReceiver 内创建子线程去做。说明：由于该方法是在主线程执行，如果执行耗时操作会导致 UI 不流畅。可以使用IntentService 、 创 建 HandlerThread 或 者 调 用 Context#registerReceiver(BroadcastReceiver, IntentFilter, String, Handler)方法等方式，在其他 Wroker 线程执行 onReceive 方法。BroadcastReceiver#onReceive()方法耗时超过 10 秒钟，可能会被系统杀死。 当前Activity的onPause方法执行结束后才会执行下一个Activity的onCreate方法，所以在 onPause 方法中不适合做耗时较长的工作，这会影响到页面之间的跳转效率 Activity或者Fragment中动态注册BroadCastReceiver时，registerReceiver()和 unregisterReceiver()要成对出现。说明：如果 registerReceiver()和 unregisterReceiver()不成对出现，则可能导致已经注册的receiver 没有在合适的时机注销，导致内存泄漏，占用内存空间，加重 SystemService负担。部分华为的机型会对 receiver 进行资源管控，单个应用注册过多 receiver 会触发管控模块抛出异常，应用直接崩溃。 添加Fragment时，确保FragmentTransaction#commit()在Activity#onPostResume()或者 FragmentActivity#onResumeFragments()内调用。不要随意使用FragmentTransaction#commitAllowingStateLoss()来代替，任何commitAllowingStateLoss()的使用必须经过 code review，确保无负面影响。说明：Activity 可能因为各种原因被销毁，Android支持页面被销毁前通过Activity#onSaveInstanceState()保存自己的状态。但如果FragmentTransaction.commit()发生在 Activity 状态保存之后，就会导致 Activity 重建、恢复状态时无法还原页面状态，从而可能出错。为了避免给用户造成不好的体验，系统会抛出 IllegalStateExceptionStateLoss 异常。推荐的做法是在 Activity 的onPostResume() 或 onResumeFragments() （ 对 FragmentActivity ） 里 执 行FragmentTransaction.commit()，如有必要也可在 onCreate()里执行。不要随意改用FragmentTransaction.commitAllowingStateLoss()或者直接使用 try-catch 避免crash，这不是问题的根本解决之道，当且仅当你确认 Activity 重建、恢复状态时，本次 commit 丢失不会造成影响时才可这么做。 【推荐】不要在 Activity#onDestroy()内执行释放资源的工作，例如一些工作线程的销毁和停止，因为 onDestroy()执行的时机可能较晚。可根据实际需要，在Activity#onPause()/onStop()中结合 isFinishing()的判断来执行。 【推荐】如非必须，避免使用嵌套的 Fragment。说明：嵌套 Fragment 是在 Android API 17 添加到 SDK 以及 Support 库中的功能，Fragment 嵌套使用会有一些坑，容易出现 bug，比较常见的问题有如下几种：1) onActivityResult()方法的处理错乱，内嵌的 Fragment 可能收不到该方法的回调，需要由宿主 Fragment 进行转发处理；2) 突变动画效果；3) 被继承的 setRetainInstance()，导致在 Fragment 重建时多次触发不必要的逻辑。非必须的场景尽可能避免使用嵌套 Fragment，如需使用请注意上述问题。 Service 需要以多线程来并发处理多个启动请求，建议使用 IntentService，可避免各种复杂的设置。说明：Service 组件一般运行主线程，应当避免耗时操作，如果有耗时操作应该在 Worker线程执行。 可以使用 IntentService 执行后台任务。 【推荐】对于只用于应用内的广播，优先使用 LocalBroadcastManager 来进行注册和发送，LocalBroadcastManager 安全性更好，同时拥有更高的运行效率。说明：对于使用 Context#sendBroadcast()等方法发送全局广播的代码进行提示。如果该广播仅用于应用内，则可以使用 来避免广播泄漏以及广播被123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126拦截等安全问题，同时相对全局广播本地广播的更高效。### **四、UI与布局**1. **布局中不得不使用 ViewGroup 多重嵌套时，不要使用 LinearLayout 嵌套，改用 RelativeLayout，可以有效降低嵌套数。**&lt;br/&gt;说明：Android 应用页面上任何一个 View 都需要经过 measure、layout、draw 三个步骤才能被正确的渲染。从 xml layout 的顶部节点开始进行 measure，每个子节点都需要向自己的父节点提供自己的尺寸来决定展示的位置，在此过程中可能还会重新measure（由此可能导致 measure 的时间消耗为原来的 **2-3** 倍）。节点所处位置越深，套嵌带来的 measure 越多，计算就会越费时。这就是为什么扁平的 View 结构会性能更好。同时，页面拥上的 View 越多，measure、layout、draw 所花费的时间就越久。要缩短这个时间，关键是保持 View 的树形结构尽量扁平，而且要移除所有不需要渲染的View。理想情况下，总共的 measure，layout，draw 时间应该被很好的**控制在 16ms以内，以保证滑动屏幕时 UI 的流畅。**要找到那些多余的 View（增加渲染延迟的 view），可以用 Android Studio Monitor里的 Hierarachy Viewer 工具，可视化的查看所有的 view。2. **在 Activity 中显示对话框或弹出浮层时，尽量使用 DialogFragment，而非Dialog/AlertDialog，这样便于随Activity生命周期管理对话框/弹出浮层的生命周期。**3. **在需要时刻刷新某一区域的组件时，建议通过以下方式避免引发全局 layout刷新:**&lt;br/&gt; 1) 设置固定的 view 大小的高宽，如倒计时组件等；&lt;br/&gt; 2) 调用 view 的 layout 方式修改位置，如弹幕组件等；&lt;br/&gt; 3) 通过修改 canvas 位置并且调用 invalidate(int l, int t, int r, int b)等方式限定刷新 区域；&lt;br/&gt; 4) 通过设置一个是否允许 requestLayout 的变量，然后重写控件的 requestlayout、 onSizeChanged 方法 ， 判 断 控 件 的大小 没 有 改 变 的 情况下 ， 当 进 入 requestLayout 的时候，直接返回而不调用 super 的 requestLayout 方法。4. **【强制】不能使用 ScrollView 包裹 ListView/GridView/ExpandableListVIew;因为这样会把 ListView 的所有 Item 都加载到内存中，要消耗巨大的内存和 cpu 去绘制图面。**&lt;br/&gt;说明：ScrollView 中嵌套 List 或 RecyclerView 的做法官方明确禁止。除了开发过程中遇到的各种视觉和交互问题，这种做法对性能也有较大损耗。ListView 等 UI 组件自身有垂直滚动功能，也没有必要在嵌套一层 ScrollView。目前为了较好的 UI 体验，更贴近 Material Design 的设计，推荐使用 NestedScrollView。### **五、进程、线程与消息通信**1. **【强制】**不要通过 Intent 在 Android 基础组件之间传递大数据（binder transaction缓存为 1MB），可能导致 OOM。2. **【强制】**新建线程时，必须通过线程池提供（AsyncTask 或者 ThreadPoolExecutor或者其他形式自定义的线程池），不允许在应用中自行显式创建线程。&lt;br/&gt;说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。另外创建匿名线程不便于后续的资源使用分析，对性能分析等会造成困扰。3. **【强制】**线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。&lt;br/&gt;**Executors 返回的线程池对象的弊端如下**：&lt;br/&gt; 1) FixedThreadPool 和 SingleThreadPool ： 允 许 的 请 求 队 列 长 度 为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM；&lt;br/&gt; 2) CachedThreadPool 和 ScheduledThreadPool ： 允 许的 创建线 程 数量 为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。4. 【强制】不要在非 UI 线程中初始化 ViewStub，否则会返回 null。5. ThreadPoolExecutor 设置线程存活时间(setKeepAliveTime)，确保空闲时线程能被释放。6. 禁 止 在多 进 程 之 间 用 SharedPreferences 共 享数 据 ， 虽 然 可 以(MODE_MULTI_PROCESS)，但官方已不推荐。7. **谨慎使用 Android 的多进程，多进程虽然能够降低主进程的内存压力，但会遇到如下问题：**&lt;br/&gt; 1) 不能实现完全退出所有 Activity 的功能；&lt;br/&gt; 2) 首次进入新启动进程的页面时会有延时的现象（有可能黑屏、白屏几秒，是白 屏还是黑屏和新 Activity 的主题有关）；&lt;br/&gt; 3) 应用内多进程时，Application 实例化多次，需要考虑各个模块是否都需要在所 有进程中初始化；&lt;br/&gt; 4) 多进程间通过 SharedPreferences 共享数据时不稳定。 ### **六、文件与数据库**1. **【强制】**任何时候不要硬编码文件路径，请使用 Android 文件系统 API 访问。 说明： Android 应用提供内部和外部存储，分别用于存放应用自身数据以及应用产生的用 户数据。可以通过相关 API 接口获取对应的目录，进行文件操作。 android.os.Environment#getExternalStorageDirectory() android.os.Environment#getExternalStoragePublicDirectory() android.content.Context#getFilesDir() android.content.Context#getCacheDir 2. 【强制】应用间共享文件时，不要通过放宽文件系统权限的方式去实现，而应使用FileProvider。正例： ```java &lt;!-- AndroidManifest.xml --&gt;&lt;manifest&gt;...&lt;application&gt; ... &lt;provider android:name=&quot;android.support.v4.content.FileProvider&quot; android:authorities=&quot;com.example.fileprovider&quot; android:exported=&quot;false&quot; android:grantUriPermissions=&quot;true&quot;&gt; &lt;meta-data android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot; android:resource=&quot;@xml/provider_paths&quot;/&gt; &lt;/provider&gt; ...&lt;/application&gt;&lt;/manifest&gt; &lt;!-- res/xml/provider_paths.xml --&gt;&lt;paths&gt;&lt;files-path path=&quot;album/&quot; name=&quot;myimages&quot;/&gt;&lt;/paths&gt; void getAlbumImage(String imagePath) &#123; File image = new File(imagePath); Intent getAlbumImageIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); Uri imageUri = FileProvider.getUriForFile(this, &quot;com.example.provider&quot;, image); getAlbumImageIntent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri); startActivityForResult(takePhotoIntent, REQUEST_GET_ALBUMIMAGE); &#125; SharedPreference 提交数据时，尽量使用 Editor#apply() ， 而非Editor#commit()。一般来讲，仅当需要确定提交结果，并据此有后续操作时，才使用Editor#commit()。说明：SharedPreference 相关修改使用 apply 方法进行提交会先写入内存，然后异步写入磁盘，commit 方法是直接写入磁盘。如果频繁操作的话 apply 的性能会优于 commit，apply 会将最后修改内容写入磁盘。但是如果希望立刻获取存储操作的结果，并据此做相应的其他操作，应当使用 commit。 多线程操作写入数据库时，需要使用事务，以免出现同步问题。说明：Android 的通过 SQLiteOpenHelper 获取数据库 SQLiteDatabase 实例，Helper 中会自动缓存已经打开的 SQLiteDatabase 实例，单个 App 中应使用 SQLiteOpenHelper的单例模式确保数据库连接唯一。由于 SQLite 自身是数据库级锁，单个数据库操作是保证线程安全的（不能同时写入），transaction 时一次原子操作，因此处于事务中的操作是线程安全的。若同时打开多个数据库连接，并通过多线程写入数据库，会导致数据库异常，提示数据库已被锁住。正例： 1234567891011121314public void insertUserPhoto(SQLiteDatabase db, String userId, String content)&#123; ContentValues cv = new ContentValues(); cv.put("userId", userId); cv.put("content", content); db.beginTransaction(); try &#123; db.insert(TUserPhoto, null, cv); db.setTransactionSuccessful(); &#125; catch (Exception e) &#123; // TODO &#125; finally &#123; db.endTransaction(); &#125;&#125; 大数据写入数据库时，请使用事务或其他能够提高 I/O 效率的机制，保证执行速度。正例： 12345678910111213141516public void insertBulk(SQLiteDatabase db, ArrayList&lt;UserInfo&gt; users)&#123; db.beginTransaction(); try &#123; for (int i = 0; i &lt; users.size; i++) &#123; ContentValues cv = new ContentValues(); cv.put("userId", users[i].userId); cv.put("content", users[i].content); db.insert(TUserPhoto, null, cv); &#125; db.setTransactionSuccessful(); &#125; catch (Exception e) &#123; // TODO &#125; finally &#123; db.endTransaction(); &#125; &#125; 【强制】执行 SQL 语句时，应使用 SQLiteDatabase#insert()、update()、delete()，不要使用 SQLiteDatabase#execSQL()，以免 SQL 注入风险。正例： 123456public int updateUserPhoto(SQLiteDatabase db, String userId, String content) &#123; ContentValues cv = new ContentValues(); cv.put("content", content); String[] args = &#123;String.valueOf(userId)&#125;; return db.update(TUserPhoto, cv, "userId=?", args); &#125; 【强制】如果 ContentProvider 管理的数据存储在 SQL 数据库中，应该避免将不受信任的外部数据直接拼接在原始 SQL 语句中，可使用一个用于将 ? 作为可替换参数的选择子句以及一个单独的选择参数数组，会避免 SQL 注入。 1234// 使用一个可替换参数String mSelectionClause = &quot;var = ?&quot;;String[] selectionArgs = &#123;&quot;&quot;&#125;;selectionArgs[0] = mUserInput; 反例: 12//拼接用户输入内容和列名String mSelectionClause = &quot;var = &quot; + mUserInput; 七、Bitmap、Drawable 与动画 【强制】加载大图片或者一次性加载多张图片，应该在异步线程中进行。图片的加载，涉及到 IO 操作，以及 CPU 密集操作，很可能引起卡顿。 12345678910class BitmapWorkerTask extends AsyncTask&lt;Integer, Void, Bitmap&gt; &#123; ... // 在后台进行图片解码 @Override protected Bitmap doInBackground(Integer... params) &#123; final Bitmap bitmap = BitmapFactory.decodeFile("some path"); return bitmap; &#125; ...&#125; 应根据实际展示需要，压缩图片，而不是直接显示原图。手机屏幕比较小，直接显示原图，并不会增加视觉上的收益，但是却会耗费大量宝贵的内存。 123456789101112public static Bitmap decodeSampledBitmapFromResource(Resources res, int resId,int reqWidth, int reqHeight) &#123; //首先通过inJustDecodeBounds=true获得图片的尺寸 final BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; BitmapFactory.decodeResource(res, resId, options); // 然后根据图片分辨率以及我们实际需要展示的大小，计算压缩率 options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight); // 设置压缩率，并解码 options.inJustDecodeBounds = false; return BitmapFactory.decodeResource(res, resId, options); &#125; 针对不同的屏幕密度，提供对应的图片资源，使内存占用和显示效果达到合理的平衡。如果为了节省包体积，可以在不影响 UI 效果的前提下，省略低密度图片。 使用 inBitmap 重复利用内存空间，避免重复开辟新内存。 1234567891011121314151617181920212223public static Bitmap decodeSampledBitmapFromFile(String filename, int reqWidth, int reqHeight, ImageCache cache) &#123; final BitmapFactory . Options options = new BitmapFactory . Options (); ... BitmapFactory.decodeFile(filename, options); ...// 如果在 Honeycomb 或更新版本系统中运行，尝试使用 inBitmap if (Utils.hasHoneycomb()) &#123; addInBitmapOptions(options, cache); &#125; ... return BitmapFactory.decodeFile(filename, options);&#125;//--------------------------------------------------------------private static void addInBitmapOptions(BitmapFactory.Options options,ImageCache cache) &#123;// inBitmap 只处理可变的位图，所以强制返回可变的位图 options.inMutable = true; if (cache != null) &#123; Bitmap inBitmap = cache.getBitmapFromReusableSet(options); if (inBitmap != null) &#123; options.inBitmap = inBitmap; &#125; &#125;&#125; 使用 ARGB_565 代替 ARGB_888，在不怎么降低视觉效果的前提下，减少内存占用。说明：android.graphics.Bitmap.Config 类中关于图片颜色的存储方式定义：1) ALPHA_8 代表 8 位 Alpha 位图；2) ARGB_4444 代表 16 位 ARGB 位图；3) ARGB_8888 代表 32 位 ARGB 位图；4) RGB_565 代表 8 位 RGB 位图。位图位数越高，存储的颜色信息越多，图像也就越逼真。大多数场景使用的是ARGB_8888 和 RGB_565，RGB_565 能够在保证图片质量的情况下大大减少内存的开销，是解决 oom 的一种方法。但是一定要注意 RGB_565 是没有透明度的，如果图片本身需要保留透明度，那么就不能使用 RGB_565。 123Config config = drawableSave.getOpacity() != PixelFormat.OPAQUE ? Config.ARGB_8888 :Config.RGB_565;Bitmap bitmap = Bitmap.createBitmap(w, h, config); 尽量减少 Bitmap （BitmapDrawable）的使用，尽量使用纯色（ColorDrawable）、渐变色（GradientDrawable）、StateSelector（StateListDrawable）等与 Shape 结合的形式构建绘图。 谨慎使用 gif 图片，注意限制每个页面允许同时播放的 gif 图片，以及单个gif 图片的大小。 在有强依赖 onAnimationEnd 回调的交互时，如动画播放完毕才能操作页面 ， onAnimationEnd 可 能 会 因 各 种 异 常 没 被 回 调 （ 参 考 ：https://stackoverflow.com/questions/5474923/onanimationend-is-not-getting-called-onanimationstart-works-fine），建议加上超时保护或通过 postDelay 替代onAnimationEnd。 12345678910111213View v = findViewById(R.id.xxxViewID);final FadeUpAnimation anim = new FadeUpAnimation(v);anim.setInterpolator(new AccelerateInterpolator());anim.setDuration(1000);anim.setFillAfter(true);new Handler().postDelayed(new Runnable() &#123; public void run() &#123; if (v != null) &#123; v.clearAnimation(); &#125; &#125;&#125;, anim.getDuration());v.startAnimation(anim); 当View Animation 执行结束时，调用 View.clearAnimation()释放相关资源。 123456789101112131415View v = findViewById(R.id.xxxViewID);final FadeUpAnimation anim = new FadeUpAnimation(v);anim.setInterpolator(new AccelerateInterpolator());anim.setDuration(1000);anim.setFillAfter(true);anim.setAnimationListener(new AnimationListener() &#123; @Override public void onAnimationEnd(Animation arg0) &#123; //判断一下资源是否被释放了 if (v != null) &#123; v.clearAnimation(); &#125; &#125;&#125;);v.startAnimation(anim); 八、安全 【强制】使用 PendingIntent 时，禁止使用空 intent，同时禁止使用隐式 Intent说明：1) 使用 PendingIntent 时，使用了空 Intent,会导致恶意用户劫持修改 Intent 的内容。禁止使用一个空 Intent 去构造 PendingIntent，构造 PendingIntent 的 Intent一定要设置 ComponentName 或者 action。2) PendingIntent 可以让其他 APP 中的代码像是运行自己 APP 中。PendingIntent的intent接收方在使用该intent时与发送方有相同的权限。在使用PendingIntent时，PendingIntent 中包装的 intent 如果是隐式的 Intent，容易遭到劫持，导致信息泄露。 【强制】将 android:allowbackup 属性设置为 false，防止 adb backup 导出数据。说明：在 AndroidManifest.xml 文件中为了方便对程序数据的备份和恢复在 Android APIlevel 8 以后增加了 android:allowBackup 属性值。默认情况下这个属性值为 true,故当 allowBackup 标志值为 true 时，即可通过 adb backup 和 adb restore 来备份和恢复应用程序数据。 【强制】Receiver/Provider 不能在毫无权限控制的情况下，将 android:export 设置为 true。 使用 Intent Scheme URL 需要做过滤。如果浏览器支持 Intent Scheme Uri 语法，如果过滤不当，那么恶意用户可能通过浏览器 js 代码进行一些恶意行为，比如盗取 cookie 等。如果使用了 Intent.parseUri函 数 ， 获 取 的 intent 必 须 严 格 过 滤 ， intent 至 少 包 含addCategory(“android.intent.category.BROWSABLE”) ， setComponent(null) ，setSelector(null)3 个策略。 正例： 12345678// 将 intent scheme URL 转换为 intent 对象Intent intent = Intent.parseUri(uri);// 禁止没有 BROWSABLE category 的情况下启动 activityintent.addCategory("android.intent.category.BROWSABLE");intent.setComponent(null);intent.setSelector(null);// 使用 intent 启动 activitycontext.startActivityIfNeeded(intent, -1) 反例： 123Intent intent = Intent.parseUri(uri.toString().trim().substring(15), 0);intent.addCategory("android.intent.category.BROWSABLE");context.startActivity(intent); 扩展参考： 121) https://jaq.alibaba.com/community/art/show?articleid=2652) https://www.mbsd.jp/Whitepaper/IntentScheme.pdf 【强制】将所需要动态加载的文件放置在 apk 内部，或应用私有目录中，如果应用必须要把所加载的文件放置在可被其他应用读写的目录中(比如 sdcard)，建议对不可信的加载源进行完整性校验和白名单处理，以保证不被恶意代码注入。 【强制】使用 Android 的 AES/DES/DESede 加密算法时，不要使用默认的加密模式ECB，应显示指定使用 CBC 或 CFB 加密模式。说明：加密模式 ECB、CBC、CFB、OFB 等，其中 ECB 的安全性较弱，会使相同的铭文在不同的时候产生相同的密文，容易遇到字典攻击，建议使用 CBC 或 CFB 模式。1) ECB：Electronic codebook，电子密码本模式2) CBC：Cipher-block chaining，密码分组链接模式3) CFB：Cipher feedback，密文反馈模式4) OFB：Output feedback，输出反馈模式 对于不需要使用 File 协议的应用，禁用 File 协议，显式设置 webView.getSettings().setAllowFileAccess(false)，对于需要使用 File 协议的应用，禁止 File协议调用 JavaScript，显式设置 webView.getSettings().setJavaScriptEnabled(false)。 Android5.0 以后安全性要求较高的应用应该使用 window.setFlag(LayoutParam.FLAG_SECURE) 禁止录屏。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle 基础语法]]></title>
    <url>%2F2019%2F03%2Fgradle-gradle-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html</url>
    <content type="text"><![CDATA[一、先来一个hello world 新建一个文件夹,并创建build.gradle文件 在build.gradle中添加如下代码123task hello &lt;&lt; &#123; println &apos;hello world&apos;&#125; 执行gradle hello命令 分析结果产生的步骤原因: 熟悉android对build.gradle不陌生，其实gradle脚本在执行时会从目标目录寻找build.gradle文件，然后根据命令中输入的task名称找对应task去执行（也可以通过-b参数指定.gradle文件）。 这个脚本定义了一个task任务叫hello，并且添加了一个action至task队列中,这个action输出hello world。 &lt;&lt;操作符被重写,用以替代doLast闭包方法在队列尾部添加action. 12345task hello &#123; doLast&#123; println &apos;hello world&apos; &#125;&#125; 最后通过命令执行hello任务(执行任务队列中所有action) PS:gradle与gradlew命令: gradlew命令其实是对gradle命令的包装w是wrapper,包装后便于团队开发过程中gradle构建版本的统一 可以通过gradle wrapper命令帮助生成gradlew命令对应所需目录文件gradlew在执行时 如果没有对应gradle对应版本会先下载gradle-wrapper.properties文件中distributionUrl中定义版本这里是4.4-bin版本 distributionBase=GRADLE_USER_HOMEdistributionPath=wrapper/distszipStoreBase=GRADLE_USER_HOMEzipStorePath=wrapper/distsdistributionUrl=https\://services.gradle.org/distributions/gradle-4.4-bin.zip //gradle发行版本下载地址 二、groovy语言(gradle开发所用脚本语言,也可以使用Kotlin) groovy是基于JVM虚拟机的一种动态语言,语法于java非常相似,并支持于java语法混合使用。并在java基础上增加闭包、DSL(领域特定语言)的支持等 字符串操作&#39;字符串&#39;、&quot;字符串&quot;单引号双引号都可以定义字符串,区别是&#39;&#39;纯粹定义字符串&quot;&quot;定义字符串可以运算。 123456789101112task string &lt;&lt; &#123; String str1 = &apos;张三&apos; //;号可以省略 String str2 = &quot;李四&quot; System.out.println(str1) System.out.println str2 //()都可以省略 println &apos;&lt;----------------------------&gt;&apos; System.out.println(str1.getClass().getName()) println str2.getClass().name //get方法可以直接像属相一样调用 println &apos;名称:$&#123;str1&#125;&apos; println &quot;名称:$&#123;str1&#125;&quot;&#125; 输入如下: 张三 李四 java.lang.String java.lang.String 名称:${str1} 名称:张三 List集合Groovy完全兼容java集合,并进行扩展使之使用起来更方便 1234567891011121314task list &lt;&lt; &#123; List list = [1,2,3,4,5] def list2 = [1,2,3,4,5] println list.class.name println list2.class.name println &apos;&lt;----------------------------&gt;&apos; println list println &quot;第1个元素:$&#123;list[0]&#125;&quot; println &quot;倒数第2个元素:$&#123;list[-2]&#125;&quot; println &quot;第2个元素到倒数第2个元素:$&#123;list[1..-2]&#125;&quot; list.each&#123; //遍历list print it+&apos;,&apos; //闭包一个参数时可省略声明默认使用it &#125;&#125; 输入如下: java.util.ArrayList java.util.ArrayList [1, 2, 3, 4, 5] 第1个元素:1 倒数第2个元素:4 第2个元素到倒数第2个元素:[2, 3, 4] 1,2,3,4,5, Map 123456789101112task map &lt;&lt; &#123; Map map = [&apos;key1&apos;:1024,&apos;key2&apos;:7788,class:&apos;classValue&apos;] println map.class println map.getClass().name //这里不能map.class.name 因为.class会认为去map中取值class键 println &apos;&lt;----------------------------&gt;&apos; println map println map[&apos;key1&apos;] println map.key2 map.each&#123; //each遍历it为Map.Entry print &quot;[$&#123;it.key&#125;,$&#123;it.value&#125;] &quot; &#125;&#125; 输出如下: classValue java.util.LinkedHashMap {key1=1024, key2=7788, class=classValue} 1024 7788 [key1,1024] [key2,7788] [class,classValue] 方法 method(param) 括号可以省略method param return 可以省略,取方法最后一行作为返回值 代码块,代码块允许当做参数传递句号如:list.each({ println it }) groovy规定代码块作为最后一个参数时可以放在括号外边 list.each(){ println it } 括号可以省略list.each{ println it } 在格式化下,就变成我们常见的模样了 123list.each &#123; println it&#125; JavaBean(模型类get set方法) 12345678910111213class Persion&#123; private String name public int getAge()&#123; 18 &#125;&#125;task getSet&lt;&lt;&#123; def p = new Persion() println &quot;name:$&#123;p.name&#125;&quot; p.name = &apos;张三&apos; println &quot;name:$&#123;p.name&#125;&quot; println &quot;age:$&#123;p.age&#125;&quot;//p.age = 12会提示编译不过&#125; 输出如下: name:nullname:张三age:18 闭包 自定闭包 12345678910task closePackage &lt;&lt; &#123; fori &#123; print it+&quot; &quot; &#125;&#125;def fori(close)&#123; for(int i in 0..9)&#123; close(i) &#125;&#125; 输出: 0 1 2 3 4 5 6 7 8 9 闭包参数 当有一个参数时默认为it,可省略声明 多个参数时须一一列出声明 1234567891011task closePackage &lt;&lt; &#123; forMap&#123; key, value-&gt; print &quot;[$&#123;key&#125;,$&#123;value&#125;] &quot; &#125;&#125;def forMap(close)&#123; def map = [&apos;hehe&apos;:1,&apos;haha&apos;:2,&apos;aaa&apos;:3] map.each&#123; close(it.key,it.value) &#125;&#125; 输出: [hehe,1] [haha,2] [aaa,3] 闭包委托(Closure)※ Groovy闭包有三个属性 this 闭包内的 this 指向的定义该闭包的类的实例对象 owner 该属性和 this 类似，但是闭包中也可以定义闭包的，如果闭包 A 内定义了闭包 B，那么闭包 B 的 owner 指向的是其外部的闭包 A delegate(委派,代表) 该值初始化时是和 owner 相同的，但是该值可以通过接口将其它对象赋值给 delegate，来实现方法的委托功能 1234567891011121314151617181920212223242526task delegate &lt;&lt; &#123; method() def d = new Delegate() d.method() d.test&#123; println &quot;this: $&#123;this.class&#125;&quot; println &quot;owner: $&#123;owner.class&#125;&quot; println &quot;delegate: $&#123;delegate.class&#125;&quot; &#125;&#125;def method()&#123; println &quot;&lt;------------out-----------------&gt;&quot; println &quot;method - this:$&#123;this.getClass().name&#125;&quot; println &quot;&lt;------------out-----------------&gt;\n&quot;&#125;class Delegate&#123; def method()&#123; println &quot;&lt;-----------Delegate-------------&gt;&quot; println &quot;method - this:$&#123;this.getClass().name&#125;&quot; println &quot;&lt;-----------Delegate-------------&gt;\n&quot; &#125; void test(Closure&lt;Delegate&gt; closure)&#123; closure(this) &#125;&#125; 输出: method - this:build_9ghntkkm9h9qlptdttc7f5l5b method - this:Delegate this: class build_9ghntkkm9h9qlptdttc7f5l5bowner: class build_9ghntkkm9h9qlptdttc7f5l5b$_run_closure1delegate: class build_9ghntkkm9h9qlptdttc7f5l5b$_run_closure1 自定义委托并调整优先级 this 无法处理，则转向 owner，最后在转给 delegate，如果再找不到，那么就会抛出异常。这就是 groovy 提供的默认的策略 this -&gt; owner -&gt; delegate 当然该顺序也是可以改变的,可以通过闭包的 resolveStrategy 属性，指定不同的策略。 Closure.OWNER_FIRST 是默认策略。如果属性或者方法存在于 owner 内，那么他可以被 owner 调用，如果不存在，则会尝试在 delegate 类中查找 Closure.DELEGATE_FIRST 颠倒了默认逻辑：delegate 是第一优先级，其次才是 owner Closure.OWNER_ONLY 将仅仅在 owner 查找需要的属性或者方法：delegate 会被忽略 Closure.DELEGATE_ONLY 将仅仅在 delegate 查找需要的属性或者方法：owner 会被忽略 Closure.TO_SELF 可以被用于当开发人员需要使用先进的元数据编程技术和希望实现一个自定义的选择策略时：这个选择将不是 owner 或者 delegate,而仅仅是 closure 类自己。当我们实现了自己的 Closure 子类时，他才是有意义的。 123456789101112131415161718192021222324252627task delegateChange &lt;&lt; &#123; persion&#123; age = 11 name = &apos;张三&apos; println this println delegate &#125; &#125;def persion(Closure&lt;Persion&gt; closure)&#123; def p = new Persion() closure.delegate = p closure.setResolveStrategy(Closure.DELEGATE_FIRST)//并不是this被修改为delegate 而是优先取delegate closure(p)&#125; class Persion&#123; private String name private int age String toString()&#123; &quot;$&#123;name&#125;, $&#123;age&#125;&quot; &#125; &#125;String toString()&#123; &quot;root&quot;&#125; 输出: root张三, 11]]></content>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View.OnTouchEvent源码解析]]></title>
    <url>%2F2019%2F03%2F%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-View-OnTouchEvent.html</url>
    <content type="text"><![CDATA[解析都在注释中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172public boolean onTouchEvent(MotionEvent event) &#123; final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; final int action = event.getAction(); //点击，长按，上下文菜单 状态统一判断支持者认为支持点击 final boolean clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE; //判断是否View的Enable状态 if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125; mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; // 可点击的禁用视图仍然会消耗触摸事件，它只是没有回应他们。 return clickable; &#125; //优先有触摸代理 if (mTouchDelegate != null) &#123; if (mTouchDelegate.onTouchEvent(event)) &#123; return true; &#125; &#125; //如果是可点击的,或者是支持ToolTip,才走DOWN MOVE UP 等触摸事件序列 if (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123; switch (action) &#123; case MotionEvent.ACTION_UP: //去除触摸屏点击标记 mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; if ((viewFlags &amp; TOOLTIP) == TOOLTIP) &#123; //隐藏tooltip handleTooltipUp(); &#125; if (!clickable) &#123; removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; break; &#125; boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123; // take focus if we don't have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123; focusTaken = requestFocus(); &#125; if (prepressed) &#123; // The button is being released before we actually // showed it as pressed. Make it show the pressed // state now (before scheduling the click) to ensure // the user sees it. setPressed(true, x, y); &#125; if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123; // This is a tap, so remove the longpress check removeLongPressCallback(); //在View不需要获取焦点时执行单击事件 if (!focusTaken) &#123; if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; //使用Runnable并发布此消息而不是直接调用performClick。这样可以在单击操作开始之前更新视图的其他可视状态。 if (!post(mPerformClick)) &#123; performClick(); &#125; &#125; &#125; if (mUnsetPressedState == null) &#123; mUnsetPressedState = new UnsetPressedState(); &#125; if (prepressed) &#123; postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); &#125; else if (!post(mUnsetPressedState)) &#123; // If the post failed, unpress right now mUnsetPressedState.run(); &#125; removeTapCallback(); &#125; mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_DOWN: //输入源是触摸屏设备。 if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) &#123; //添加手指按下flag , 目前仅用于toolTip(Android-25) mPrivateFlags3 |= PFLAG3_FINGER_DOWN; &#125; mHasPerformedLongPress = false; if (!clickable) &#123;//不是可点击那就是toolTip checkForLongClick(0, x, y); break; &#125; //判断是否是鼠标右键,是则显示上线文菜单 if (performButtonActionOnTouchDown(event)) &#123; break; &#125; // 遍历层次结构以确定我们是否在滚动容器内。 boolean isInScrollingContainer = isInScrollingContainer(); // For views inside a scrolling container, delay the pressed feedback for // a short period in case this is a scroll. if (isInScrollingContainer) &#123; //添加预按压状态 mPrivateFlags |= PFLAG_PREPRESSED; if (mPendingCheckForTap == null) &#123; //实例化预按压Runable,执行setPressed和checkForLongClick mPendingCheckForTap = new CheckForTap(); &#125; mPendingCheckForTap.x = event.getX(); mPendingCheckForTap.y = event.getY(); postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); &#125; else &#123; //显示按下反馈 setPressed(true, x, y); //设置长按任务延时开始执行 checkForLongClick(0, x, y); &#125; break; case MotionEvent.ACTION_CANCEL: if (clickable) &#123; setPressed(false); &#125; removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; break; case MotionEvent.ACTION_MOVE: if (clickable) &#123; //更改对应drawable背景变化 drawableHotspotChanged(x, y); &#125; //判断移动是否超出当前View , mTouchSlop是溢出值(手指粗看似没出View实则x,y已不再View内添加溢出值规避) if (!pointInView(x, y, mTouchSlop)) &#123; // Outside button // Remove any future long press/tap checks removeTapCallback(); removeLongPressCallback(); //如果有按压状态则去除按压状态(PFLAG_PRESSED实在setPressed(true)时添加上的 if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125; mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; &#125; break; &#125; return true; &#125; return false;&#125;]]></content>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle 构建脚本基础]]></title>
    <url>%2F2019%2F03%2Fgradle-gradle-Java%E6%9E%84%E5%BB%BA.html</url>
    <content type="text"><![CDATA[一、setting.gradle文件gradle设置文件默认名称 setting.gradle , 存放于项目根目录 配置子工程 在Android Studio中Project和Module , 其中 Module就是Project的子工程需要在配置 如: 12include &apos;:app&apos; , &apos;:lib&apos;project(&apos;lib&apos;).projectDir = new File(rootDir,&quot;libs/lib&quot;) Build文件 每个Project或Module都会有一个Build , 该文件是构建入口 可以在Build文件中进行版本、插件、依赖等配置 在Root目录中可以获取到所有Child Build文件进行配置 123456allprojects &#123; //subprojects repositories &#123; google() jcenter() &#125;&#125; subprojects和allprojects方法接受闭包对工程进行遍历设置 Task 一个Project或者Module对应有多个Task组成 一个Task是一个原子操作 Task之见可以相互依赖 创建Task 1234567task task1&#123; doFirst&#123;&#125; doLast&#123;&#125;&#125;tasks.create(&quot;task2&quot;)&#123; doFirst&#123;&#125;&#125; Task之间依赖 12345678910task task1&#123; doFirst&#123; println &apos;task-1&apos;&#125;&#125;task task2(dependsOn:task1)&#123; doFirst&#123; println &apos;task-2&apos;&#125;&#125;task task3&#123; //这里并不会执行两边task1 dependsOn task1,task2 doFirst&#123; println &apos;task-3&apos;&#125;&#125; 输入: gradle -q task1task-1gradle -q task2task-1task-2gradle -q task3task-1task-2task-3 自定义属性 通过应用所属ext属性添加 , 相比局部变量自定义属性更广泛作用域跨Project跨Task访问 12345678ext.age = 18ext&#123; phone = &apos;1503***9312&apos; address = &apos;北京&apos;&#125;task task1&lt;&lt;&#123; println &quot;age:$&#123;age&#125; , phone:$&#123;phone&#125; , address:$&#123;address&#125;&quot;&#125; 输出 C:\Users\cm\Desktop\test_gradle&gt;gradle -q task1age:18 , phone:1503***9312 , address:北京 SourceSet中添加属性 1234567891011121314151617apply plugin: &quot;java&quot;sourceSets.all&#123; ext.aa = &quot;aa&quot;&#125;sourceSets&#123; main&#123; aa = &quot;main-aa&quot; &#125; test&#123; aa = &apos;test-aa&apos; &#125;&#125;task task1&lt;&lt;&#123; sourceSets.each&#123; println &quot;$&#123;it.name&#125;的aa是$&#123;it.aa&#125;&quot; &#125;&#125; 输出 C:\Users\cm\Desktop\test_gradle&gt;gradle -q task1main的aa是main-aatest的aa是test-aa]]></content>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通用程序设计（45条-56条）]]></title>
    <url>%2F2019%2F03%2F%E9%9A%8F%E7%AC%94-%E9%80%9A%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%8845%E6%9D%A1-56%E6%9D%A1%EF%BC%89.html</url>
    <content type="text"><![CDATA[局部变量 控制结构 类库的用法 字符串的使用 优化与命名惯例 45条：将局部变量的作用最小化 第一次使用时声明，防止提早声明导致变量混乱以及后续阅读不便 尽量保证声明时初始化 如果没有足够的信息初始化，应该尽量推迟声明 try-catch语句例外 如果循环终止之后不再需要循环变量内容，for循环优先于while循环 12345678910111213 for(Item i : items) &#123; doSomeThing(i); &#125; Iterator i = c.iterator(); while(i.hasNext())&#123; doSomething(i.next()); &#125; Iterator i2 = c.iterator();while (i.hasNext())&#123; //i.hasNext()会返回false,导致下面的代永远不会执行 doSomething(i2.next());//永远不会执行&#125; 46条：for-each循环优先于传统的for循环 对比写法 1234567for(int i = 0; i &lt; 10; i++)&#123; doSomeThing(i);&#125;for(Element e : elements)&#123; doSomeThing(e);&#125; 思考一个例子(找BUG) 123456789101112enum Suit&#123; CLUB,DIAMOND,HEART,SPADE&#125; //四种花色enum Rank&#123; ACE,DEUCE,THREE,FOUR,FIVE,SIX, SEVEV,EIGHT,NINE,TEN,JACK,QUEEN,KING &#125;//每种花色13张牌class Card(suit:Suit,rank:Rank); Collection&lt;Suit&gt; suits = Arrays.asList(Suit.values());Collection&lt;Rank&gt; ranks = Arrays.asList(Rank.values());List&lt;Card&gt; deck= new ArrayList&lt;Card&gt;(); for (Iterator&lt;Suit&gt; i = suits.iterator();i.hasNext();) for (Iterator&lt;Rank&gt; j = ranks.iterator();j.hasNext();) deck.add(new Card(i.next(), j.next())); BUG：数字循环13次，花色有4种i.next()4次执行以后抛出java.util.NoSuchElementException没有元素异常 更换两个for循环位置可以解决么？ 123for (Iterator&lt;Rank&gt; j = ranks.iterator();j.hasNext();) for (Iterator&lt;Suit&gt; i = suits.iterator();i.hasNext();) deck.add(new Card(i.next(), j.next())); 两种种解法 要么在循环花色时提出一个局部变量引用 1234for (Iterator&lt;Suit&gt; i = suits.iterator();i.hasNext();) Suit suit = i.next(); for (Iterator&lt;Rank&gt; j = ranks.iterator();j.hasNext();) deck.add(new Card(suit, j.next())); 使用for-each替换传统for循环 123for (Suit suit:Suit.values()) for (Rank rank:Rank.values()) deck.add( new Card(suit, rank)); 三种例外不能使用for-each 过滤(需要Iterator引用调用remove时) 转换（如：冒泡时需要同时使用前后两个元素） 平行迭代（同时迭代多个集合时） 47条：了解和使用类库1. 小例子（返回一个小于n的随机数)1234private static final Random rnd = new Random();public static int random(int n)&#123; return Math.abs(rnd.nextInt()) % n;&#125; 如果n是一个比较小的2的乘方（2n），经过一段相当短的周期之后，它产生的随机数会重复。 如果n不是2的乘法时，有些数值会出现的更频繁一些。（量级比较大时会出现百分66.6概率出现前半段数值之内） Math.abs()对Integer.MIN_VALUE去非负时返回Integer.MIN_VALUE 如果要修正错误需，了解伪随机数生成器、数论、2的补码算法等相关知识。 2. 使用类库中方法 直接使用Random.nextInt(int)避免问题 多了解类库，多阅读类库实现原理及实现方式，类库的代码比你自己编写的代码更好一些，并随着时间推移而不断改进。 java.io java.lang java.util java.util.concurrent 48条：如果要精确的答案，请避免使用float和double使用float和double计算时，结果并不精确而是较为精确的快速近似结果,y尤其不能用来计算金钱。如：12System.out.println(1.03 - 0.42);//输出结果是0.610000000000000001System.out.println(1.00 - 9 * 0.1);//输出结果是0.099999999999999998 代替方式 使用BigDecimal计算 与float和double相比很不方便 计算速度很慢 使用int或long代表更小单位计算（如时间计算中微秒，钱的计算中当做分而不是元） 49条：基本类型优先于装箱基本类型 基本类型 装箱基本类型 int Integer float Float double Double … … java-1.5加入自动装箱与自动拆箱（Integer a = 10; int b = a），这些特性并没有完全抹去基本类型与装箱基本类型区别。如：12345Comparator&lt;Integer&gt; comparator = new Comparator&lt;Integer&gt;()&#123; public int compare(Integer first,Integer second)&#123; return first &lt; second ? -1 : (first == second ? 0 : 1); &#125;&#125; 不考虑null，比较new Integer(42)和new Integer(42)，返回1而不是0 50条：如果其他类型更适合，则尽量避免使用字符串 字符串不适合代替其它的值类型（如使用gson解析时模型类不要都定义成String） 字符串不适合替代枚举类型枚举类型比字符串更加适合用来表示枚举类型的常量 字符串不适合代替聚集类型如果一个实体有多个组件，用一个字符串来表示这个实体通常是不恰当的String compoundKey = className + &quot;#&quot; + i.next();为了拿到组件信息就必须解析字符串，还不可以使用equals、toString或者compareTo等方法。更好的做法是，简单的编写一个类来描述这个数据集，通常是一个私有的静态成员类。 51条：当心字符串连接的性能 字符串是不可变的，当使用+链接时，会拷贝两个字符串到一个更大的字符串中。少量固定长度时可以使用非常适合，大量拼接时特别耗时。 在字符串大量拼接时使用StringBuffer或者使用非同步的StringBuild来代替String。二者比使用+链接String快几十倍以上。 52条：通过接口引用对象12List&lt;X&gt; list= new ArrayList&lt;X&gt;() Map&lt;X,X&gt; map = new HashMap&lt;X,X&gt;() 尽量使用接口而不是类作为参数的类型 如果没有合适的接口，可以使用父类,基类做引用对象 利用多态,达到方便扩展的目的 53条：接口优先于反射机制 使用反射时损失： 丧失了编译时类型检查的好处，包括异常检査（反射方式调用不存在的或者不可访问的方法） 执行反射访问所需要的代码非常笨拙和冗长 性能 增加阅读难度，代码冗余 合理使用反射，甚至必须依赖反射，如APT框架，keyboard中的Cube集成时，通过反射注解生成云控调用方法。 反射机制是一种功能强大的机制，对于特定的复杂系统编程任务，它是非常必要的，但它也有一些缺点。如果非必要请避免使用。 54条：谨慎使用本地（native）方法使用native的方法提高性能不提倡，随着java的迭代，native方法不一定比java方法快。如在java1.1版本时BigInteger，为提高性能使用C编写，到了java1.3版本已经完全改用java编写并进行了性能优化。1.3版本中BigInteger比1.1版本更快。在这些年VM已经变得很快了 55条：谨慎地进行优化 不要因为性能而牺牲合理的结构。要努力编写好的程序而不是快的栏序。 在每次试图做优化之前和之后，要对性能进行测量。你可能会惊讶于自己的发现。试图做的优化通常对于性能井没有明显的影响，甚至会使性能变得更差。 不要费力去编写快速的程序——应该努力编写好的程序，速度自然会随之而来。在设计系统的时候，特别是在设计API、线路层协议和永久数据格式的时候，一定要考虑性能的因素。当构建完系统之后，要测量它的性能。如果它足够快，你的任务就完成了。 56条：遵守普遍接受的命名惯例 包的名称 以组织的Internet域名开头，例如：com.cmcm、com.sun 包名称的其余部分应该包括一个或者多个描述该包的组成部分。这些组成部分应该比较简短，通常不超过8个字符。鼓励使用有意义的缩写形式。如使用utils而不是utilities 类和接口的名称 遵循大驼峰法命名。如：TimerTask、HttpUrl 方法和域的名称 常量域：包括一个或多个大写的单词，中间用下划线隔开。常量域是唯一一个推荐使用下划线的情形。 成员变量 m开头、静态变量 s开头、 boolean变量 使用is开头 泛型时名称：T表示任意类型的，E表示集合元素类型，K和V表示映射的键和值类型，X表示异常。同时使用多个任何类型的时，可以是T、U、V或者T1、T2、T3。 转换类型的方法、返回不同的类型独立对象方法，通常被称为toType，例如toString和toArray]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2F2019%2F03%2FMarkdow%E8%AF%AD%E6%B3%95.html</url>
    <content type="text"><![CDATA[(来自GFM) 横线 ***、—、___可以显示横线效果 标题一级标题二级标题三级标题四级标题五级标题六级标题文本普通文本这是一段普通的文本 单行文本Hello,大家好，我是Mainli。 在一行开头加入1个Tab或者4个空格。 文本块语法1在连续几行的文本开头加入1个Tab或者4个空格。 欢迎到访 很高兴见到您 祝您，早上好，中午好，下午好，晚安 语法2使用一对各三个的反引号：123欢迎到访我是C++码农你可以在知乎、CSDN、简书搜索【Mainli】找到我 该语法也可以实现代码高亮，见代码高亮 文字高亮文字高亮功能能使行内部分文字高亮，使用一对反引号。语法：1`linux` `网络编程` `socket` `epoll` 效果：linux 网络编程 socket epoll 也适合做一篇文章的tag 换行直接回车不能换行，可以在上一行文本后面补两个空格，这样下一行的文本就换行了。 或者就是在两行文本直接加一个空行。 也能实现换行效果，不过这个行间距有点大。 斜体、粗体、删除线 语法 效果 *斜体1* 斜体1 _斜体2_ 斜体2 **粗体1** 粗体1 __粗体2__ 粗体2 这是一个 ~~删除线~~ 这是一个 删除线 ***斜粗体1*** 斜粗体1 ___斜粗体2___ 斜粗体2 ***~~斜粗体删除线1~~*** 斜粗体删除线1 ~~***斜粗体删除线2***~~ 斜粗体删除线2 斜体、粗体、删除线可混合使用 图片基本格式：1![alt](URL title) alt和title即对应HTML中的alt和title属性（都可省略）： alt表示图片显示失败时的替换文本 title表示鼠标悬停在图片时的显示文本（注意这里要加引号） URL即图片的url地址，如果引用本仓库中的图片，直接使用相对路径就可了，如果引用其他github仓库中的图片要注意格式，即：仓库地址/raw/分支名/图片路径，如：1https://github.com/guodongxiaren/ImageCache/raw/master/Logo/foryou.gif # 语法 效果 1 ![baidu](https://www.baidu.com/img/bdlogo.gif &quot;百度logo&quot;) 2 ![][foryou] 注意例2的写法使用了URL标识符的形式，在链接一节有介绍。 在文末有foryou的定义：1[foryou]:https://github.com/guodongxiaren/ImageCache/raw/master/Logo/foryou.gif 链接链接外部URL # 语法 效果 1 [我的博客](https://blog.csdn.net/guodongxiaren &quot;悬停显示&quot;) 我的博客 2 [我的知乎][zhihu] 我的知乎 语法2由两部分组成： 第一部分使用两个中括号，[ ]里的标识符（本例中zhihu），可以是数字，字母等的组合，标识符上下对应就行了（姑且称之为URL标识符） 第二部分标记实际URL。 使用URL标识符能达到复用的目的，一般把全文所有的URL标识符统一放在文章末尾，这样看起来比较干净。 URL标识符是我起的名字，不知道是否准确。囧。。 链接本仓库里的URL 语法 效果 [我的简介](/example/profile.md) 我的简介 [example](./example) example 图片链接给图片加链接的本质是混合图片显示语法和普通的链接语法。普通的链接中[ ]内部是链接要显示的文本，而图片链接[ ]里面则是要显示的图片。直接混合两种语法当然可以，但是十分啰嗦，为此我们可以使用URL标识符的形式。 # 语法 效果 1 [![weibo-logo]](https://weibo.com/linpiaochen) 2 [![](/img/zhihu.png &quot;我的知乎，欢迎关注&quot;)][zhihu] 3 [![csdn-logo]][csdn] 因为图片本身和链接本身都支持URL标识符的形式，所以图片链接也可以很简洁（见例3）。注意，此时鼠标悬停时显示的文字是图片的title，而非链接本身的title了。 本文URL标识符都放置于文末 锚点其实呢，每一个标题都是一个锚点，和HTML的锚点（#）类似，比如我们 语法 效果 [回到顶部](#readme) 回到顶部 不过要注意，标题中的英文字母都被转化为小写字母了。 以前GitHub对中文支持的不好，所以中文标题不能正确识别为锚点，但是现在已经没问题啦！ 列表无序列表语法123* 昵称：Mainli- 别名：Mainli* 英文名：Mainli 效果 昵称：Mainli 别名：Mainli 英文名：Mainli 多级无序列表语法123* 编程语言 * 脚本语言 * Python 效果 编程语言 脚本语言 Python 一级有序列表语法就是在数字后面加一个点，再加一个空格。不过看起来起来可能不够明显。12345面向对象的三个基本特征：1. 封装2. 继承3. 多态 效果面向对象的三个基本特征： 封装 继承 多态 多级有序列表和无序列表一样，有序列表也有多级结构。 语法1231. 这是一级的有序列表，数字1还是1 1. 这是二级的有序列表，阿拉伯数字在显示的时候变成了罗马数字 1. 这是三级的有序列表，数字在显示的时候变成了英文字母 效果 这是一级的有序列表，数字1还是1 这是二级的有序列表，阿拉伯数字在显示的时候变成了罗马数字 这是三级的有序列表，数字在显示的时候变成了英文字母 复选框列表语法123456- [x] 需求分析- [x] 系统设计- [x] 详细设计- [ ] 编码- [ ] 测试- [ ] 交付 效果 需求分析 系统设计 详细设计 编码 测试 交付 您可以使用这个功能来标注某个项目各项任务的完成情况。 Tip: 在GitHub的issue中使用该语法是可以实时点击复选框来勾选或解除勾选的，而无需修改issue原文。 块引用常用于引用文本文本摘自《深入理解计算机系统》P27 令人吃惊的是，在哪种字节顺序是合适的这个问题上，人们表现得非常情绪化。实际上术语“little endian”（小端）和“big endian”（大端）出自Jonathan Swift的《格利佛游记》一书，其中交战的两个派别无法就应该从哪一端打开一个半熟的鸡蛋达成一致。因此，争论沦为关于社会政治的争论。只要选择了一种规则并且始终如一的坚持，其实对于哪种字节排序的选择都是任意的。 “端”（endian）的起源以下是Jonathan Swift在1726年关于大小端之争历史的描述：“……下面我要告诉你的是，Lilliput和Blefuscu这两大强国在过去36个月里一直在苦战。战争开始是由于以下的原因：我们大家都认为，吃鸡蛋前，原始的方法是打破鸡蛋较大的一端，可是当今的皇帝的祖父小时候吃鸡蛋，一次按古法打鸡蛋时碰巧将一个手指弄破了，因此他的父亲，当时的皇帝，就下了一道敕令，命令全体臣民吃鸡蛋时打破较小的一端，违令者重罚。” 块引用有多级结构语法12345&gt; 数据结构&gt;&gt; 树&gt;&gt;&gt; 二叉树&gt;&gt;&gt;&gt; 平衡二叉树&gt;&gt;&gt;&gt;&gt; 满二叉树 效果 数据结构 树 二叉树 平衡二叉树 满二叉树 代码高亮语法在三个反引号后面加上编程语言的名字，另起一行开始写代码，最后一行再加上三个反引号。 效果1public static void main(String[]args)&#123;&#125; //Java 1int main(int argc, char *argv[]) //C 1echo "hello GitHub" #Bash 1document.getElementById("myH1").innerHTML="Welcome to my Homepage"; //javascipt 1string &amp;operator+(const string&amp; A,const string&amp; B) //cpp 表格 表头1 表头2 表格单元 表格单元 表格单元 表格单元 表头1 表头2 表格单元 表格单元 表格单元 表格单元 对齐表格可以指定对齐方式 左对齐 居中 右对齐 col 3 is some wordy text $1600 col 2 is centered $12 zebra stripes are neat $1 混合其他语法表格单元中的内容可以和其他大多数GFM语法配合使用，如： 使用普通文本的删除线，斜体等效果 名字 描述 Help Display the help window. Close Closes a window 表格中嵌入图片（链接）其实前面介绍图片显示、图片链接的时候为了清晰就是放在在表格中显示的。 图片 描述 百度 表情Github的Markdown语法支持添加emoji表情，输入不同的符号码（两个冒号包围的字符）可以显示出不同的表情。 比如:blush:，可以显示:blush:。 具体每一个表情的符号码，可以查询GitHub的官方网页http://www.emoji-cheat-sheet.com。 但是这个网页每次都打开奇慢。。所以我整理到了本repo中，大家可以直接在此查看emoji。 diff语法版本控制的系统中都少不了diff的功能，即展示一个文件内容的增加与删除。GFM中可以显示的展示diff效果。使用绿色表示新增，红色表示删除。 语法其语法与代码高亮类似，只是在三个反引号后面写diff，并且其内容中，以 +开头表示新增，-开头表示删除。 效果12+ 鸟宿池边树，僧敲月下门- 鸟宿池边树，僧推月下门]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
